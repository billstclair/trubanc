setup.php defines the $dbdir, which is the base of the database in the
file system. Here's how the bank directory is structured.

Items in angle brackets are variables
Items not in angle brackets are literals
"--" comment to the end of the line
<dir>/ is a directory
<key>=<value> is a file named <key> with contents <value>
Items whose names end with "#" are sequence numbers.
name:<item> denotes an optional item, passed by position or name
Items in parens are signed. Signature omitted here.

$dbdir/
  sequence=<sequence#>  -- The transaction sequence number
  privkey=<privkey>   -- the private key. Maybe this shouldn't be in
                      -- the database, so it doesn't get backed up.
  bankid=<bankid>  -- The id of the private key
  regfee=<regfee>  -- Usage tokens paid for registration
                   -- default: 10 (2 each for /pubkey & /pubkeysig,
                   --              <id>, last, balance, outbox, inbox,
                   --              and one bonus token)
  )
  regfeesig=(<bankid>,regfee,<fee#>,0,<amount>)
  tranfee=<tranfee>  -- Usage tokens paid for a transaction.
                      -- Returned when the transaction completes.
                      -- Default: 2 (inbox & outbox entry)
  tranfeesig=(<bankid>,tranfee,<fee#>,0,<amount>)
  fee/  -- permanent fees, paid for transactions of the given type
        -- Default: none
    spend=<asset#>:<amount>[.<asset#>:<amount>...]
    note=<asset#>:<amount>[.<asset#>:<amount>...]
    createasset=<asset#>:<amount>[.<asset#>:<amount>...]
  feesig/
    spend=(<bankid>,fee|spend,<fee#>,<asset#>,<amount>)[...]
    note=(<bankid>,fee|note,<fee#>,<asset#>,<amount>)[...]
    createasset=(<bankid>,fee|createasset,<fee#>,<asset#>,<amount>)[...]
  pubkey/
    <id>=<pubkey>
  pubkeysig/
    <id>=(<bankid>,pubkey,<pubkey>,name>)
  asset/ -- <asset#> 0 is "usage tokens"
    <asset#>=(<id>,asset,<asset#>,<scale>,<precision>,<assetname>)
  assetname/
    <name>=<asset#>
  account/
    <id>/
      last=<sequence#>  -- new transactions must have higher sequence
      lastrequest=<request#>  -- new requests must have a higher number
      balance/
        <name>/  -- "main" is the default balance name
          <asset#>=(<id>,balance,<tran#>,<asset#>,<amount>,acct:<acct>)
      outbox/
        <tran#>=(<id>,spend,<tran#>,<id2>,<asset#>,<amount>,note:<note>,acct:<acct>)
        <re#>=(<id>,note,<re#>,<id2>,re:<re2#>,note:<note>)
      outboxhash=(<id>,outboxhash,<tran#>,<hash>)
      inbox/
        <tran#>=(<id2>,spend|accept,<tran2#>,note:<note2>,acct:<acct2>)
        <tran#>=(<id3>,spend|reject,<tran3#>,note:<note3>)
        <re2#>=(<id4>,note,<re2#>,<id>,<re#>,note:<note4>)


=== Transactions ===


Look up pubkey
--------------

  Customer sends:

(<id>,id,<id2>)

  Use 0 for <id2> to look up the bank's key.
  If there is such an id registered, bank responds with:

(<id2>,register,<pubkey>,name=<name>)

  If there is no such id, bank responds with:

(<bankid>,failed,(<id>,id,<id2>),reason:<reason>)

  A note about looking up the bank's public key. It can only be done
  by registered customers. If an unregistered customer sends
  (<id>,id,0), the <id> will be unknown, so the signature verification
  of the message will fail.


Create account
--------------

  Customer sends:

(<id>,register,<pubkey>,name=<name>)

  If the id is new, matches the pubkey, the signature is OK, and the
  customer has enough usage tokens in his inbox (spending usage tokens
  to a new <id> is how the account directory is actually created),
  bank responds with:

(<id>,register,<pubkey>,name=<name>)

  This is the first time the bank will have seen the customer's
  pubkey.  The parsing code notices these "id" messages, and verifies
  pubkey if unknown, before using it to verify the registration
  message itself.  Customer will need to process his inbox to transfer
  his introduction tokens to his balance. No spend|cancel operations
  will be allowed for usage token spends to an account with a negative
  usage token balance. This ensures that the usage token balance will
  be positive after the new customer processes his inbox.

  Otherwise, bank puts a negative balance (/regfee) of usage tokens in
  the balance, and responds with:

(<bankid>,failed,(<id>,register,<pubkey>),reason:<reason>)

  Note that the customer won't be able to verify the signature on this
  message, since he doesn't know the bank's public key, and can't get
  it until he has successfully completed his registration.


Get last request
----------------

  Customer sends:

(<id>,getlastrequest,<random>)

  Bank sends:

(<bankid>, lastrequest, <request#>)

  Note that this request can be replayed. The customer needs to have
  some way of getting back in sync for requests. This is it.
  It makes no changes to the server database, just returns the
  customer's most recent request <request#>.


Get sequence number
-------------------

  Customer sends:

(<id>,sequence,<request#>)

  Bank compares <request#> to /accounts/<id>/lastrequest. If
  <request#> is greater, bank sets /account/<id>/lastrequest to
  <request#>, increments /sequence to <sequence#>, and returns:

(<bankid>,sequence,<sequence#>)

  Otherwise, bank returns

(<bankid>,failed,(<id>,sequence,<random>),reason:<reason>)


Get fees
--------

  Customer sends:

(<id>,getfees,<operation>,<request#>)

  <operation> can be "*" to return all fees.
  Bank compares <request#> to /account/<id>/lastrequest. If <request#>
  is greater, bank sets /account/<id>/lastrequest to <request#>,
  increments /sequence to <sequence#>, and returns /regfeesig,
  /tranfeesig, and /feesig/<operation>:

(<bankid>regfee,0,<fee#>,<amount>).
  (<bankid>,tranfee,<fee#>,0,<amount>).
  (<bankid>,fee|<operation>,<fee#>,<asset#>,<amount>).
  (<bankid>,fee|<operation2>,<fee2#>,<asset2#>,<amount2>).
  ...
  (<bankid>,fee|<operationN>,<feeN#>,<assetN#>,<amountN>)

  Otherwise, bank returns:

(<bankid>,failed,(<id>,getfees,<operation>,<request#>),reason:<reason>)


Spend
-----

  Customer sends the following. Second and subsequent balance items
  are for the fee assets. Fees always come from the same account
  <name> as the spend. This allows limitations on licensed spends (not
  defined yet) from a particular account <name>. Or maybe we should
  have a particular account name, assigned by the customer, defaulting
  to "main" for all fees.

(<id>,spend,<tran#>,<id2>,<asset#>,<amount>,note:<note>,acct:<name>).
  (<id>,balance,<tran#>,<asset#>,<amount>,acct:<acct>).
  (<id>,balance,<tran#>,<asset2#>,<amount2>,acct:<acct2>).
  ...
  (<id>,balance,<tran#>,<assetN#>,<amountN>,acct:<acctN>).
  (<id>,outboxhash,<tran#>,<hash>)

  Bank checks that the <tran#> is greater than /account/<id>/last,
  that the balance (after subtracting the spend amount) and hash of
  list of outbox transaction numbers (including the new spend
  transaction number) match what the customer sent. If they match,
  bank updates /account/<id>/last to <tran#>, stores the spend in
  /account/<id>/outbox/<tran#> and /account/<id2>/inbox/ (after
  finding a unique transaction number bigger than all the others
  there), sets /account/<id>/balance/<name>/<asset#> to the customer's
  balance item, updates /account/<id>/outboxhash with the customer's
  outboxhash item, and sends:

(<id>,spend,<tran#>,<id2>,<asset#>,<amount>,note:<note>,acct:<name>).
  (<bankid>,balance,<tran#>,<asset#>,<amount>,acct:<acct>).
  (<bankid>,balance,<tran#>,<asset2#>,<amount2>,acct:<acct2>).
  ...
  (<bankid>,balance,<tran#>,<assetN#>,<amountN>,acct:<acctN>).
  (<bankid>,outboxhash,<tran#>,<hash>)

If they don't match, bank returns:

(<bankid>,failed,(<id>,spend,<tran#>,<id2>,<asset#>,<amount>,note:<note>,acct:<name>),reason:<reason>).
  (<id>,balance,<tran#>,<asset#>,<amount>,acct:<acct>).
  (<id>,outboxhash,<tran#>,<hash>)


Send Note
---------

  Customer sends:

(<id>,note,<tran4#>,<id2>,<note4>,re:<re#>).
  (<bankid>,balance,<tran#>,<asset#>,<amount>,acct:<acct>).
  (<bankid>,balance,<tran#>,<asset2#>,<amount2>,acct:<acct2>).
  ...
  (<bankid>,balance,<tran#>,<assetN#>,<amountN>,acct:<acctN>)

  Bank checks that the <tran#> is greater than /account/<id>/last and
  that the balances (after subtracting the fees) match what the
  customer sent. If they match, bank updates /account/<id>/last to
  <tran#>, stores the note in /account/<id2>/inbox/ (after finding a
  unique <in#> bigger than all the others there), sets
  /account/<id>/balance/<name>/<assetN#> to the customer's balance
  items, and sends:

(<id>,note,<tran#>).
  (<bankid>,balance,<tran#>,<asset#>,<amount>,acct:<acct>).
  (<bankid>,balance,<tran#>,<asset2#>,<amount2>,acct:<acct2>).
  ...
  (<bankid>,balance,<tran#>,<assetN#>,<amountN>,acct:<acctN>)

  Otherwise, bank sends:

(<bankid>,failed,(<bankid>,note,<tran4#>))

  Note that no outboxhash is sent because outgoing notes are not
  stored in the outbox. They're only stored in the recipients inbox.

  Note that the note failure message doesn't quote the request. Notes
  may be big (probably, there will be a limit), and sending it back
  doesn't help anything, since the customer will have to have stored
  all the expected balances and outboxhash, to compare with what the
  bank sends back.


Query Inbox
------------

  Customer sends:

(<id>,inbox,<request#>)

  Bank compares <request#> to /account/<id>/lastrequest. If <request#>
  is greater, bank sets /account/<id>/lastrequest to <request#> and
  responds with contents of /account/<id>/inbox/, separated by
  periods:

(<bankid>,inbox,<in1#>,(<id2>,spend,<tran2#>,note:<note2>)).
  (<bankid>,inbox,<in2#>,(<id3>,spend,<tran3#>,note:<note3>)).
  (<bankid>,inbox,<in3#>,(<id4>,note,<tran4#>,<id>,<note4>,re:<re#>))

  Otherwise, bank sends:

(<bankid>,failed,(<id>,inbox,<request#>),reason=<reason>)

Note that the bank needs to wrap each inbox item with a message
holding the name of the item in the customer's inbox. Since customers
can number their own transactions, instead of asking the bank to
allocate them, there may be two messages in the inbox at the same time
with the same sending customer's transaction number. So the bank picks
a unique <in#> for each.


Process Inbox
-------------

  Customer sends:

(<id>,processinbox,in1#|in2#|in3#,accts=<acct>|<acct2>).
  (<id>,spend|accept,<id2>,<tran2#>,note:<note5>).
  (<id>,spend|reject,<id3>,<tran3#>,note:<note6>).
  (<id>,balance,<tran4#>,<asset#>,<amount>,acct:<acct>).
  (<id>,balance,<tran4#>,<asset2#>,<amount2>,acct:<acct2>).
  ...
  (<id>,balance,<tran4#>,<assetN#>,<amount3>,acct:<acctN>).
  (<id>,outboxhash,<tran4#>,<hash>)

Bank processes the requested inbox transaction2, and compares the
result to the balances and outboxhash sent by customer. If correct,
bank removes the listed transactions from /account/<id>/inbox/,
removes the corresponding transactions from /account/<id>/outbox/,
updates the /account/<id>/balance/<nameN>/<assetN#> with the balances
the customer sent, updates /account/<id>/outboxhash with the
outboxhash item the customer sent, and sends back:

(<bankid,affirm,(<id>,removeinbox,<inbox1#>|<inbox2#>|<inbox3#>)).
  (<bankid>,balance,<tran4#>,<asset#>,<amount>,acct:<acct>).
  (<bankid>,balance,<tran4#>,<asset2#>,<amount2>,acct:<acct2>).
  ...
  (<bankid>,balance,<tran4#>,<assetN#>,<amount3>,acct:<acctN>).
  (<bankid>,outboxhash,<tran#>,<hash>)

  Otherwise, bank returns:

(<bankid>,failed,(<id>,removeinbox,<tran2#>|<tran3#>|<tran4#>),reason=<reason>)

Note that this doesn't automatically send notice of delivery of
notes. Maybe it should, but probably better to preserve people's
privacy. If you want to know if they saw your note, give them a small
spend. They have to accept or reject it to get it out of their inbox.

Note that <acct2> is included in the "processinbox" message above only
to illustreate the syntax. A destination account for a rejected
spend makes no sense.


Lookup asset
------------

  Customer sends:

(<id>,getasset,<asset#>,<request#>)

  Bank compares <request#> to /account/<id>/lastrequest. If <request#>
  is greater, bank sets /account/<id>/lastrequest to <request#>. Then,
  if <asset#> exists in /asset, bank returns:

(<bankid>,affirm,(<issuerid>,asset,<asset#>,<assetname>))

  Otherwise, bank returns:

(<bankid>,failed,(<id>,getasset,<asset#>,<random>),reason:<reason>)


Create asset
------------

  Customer sends:

(<id>,asset,<asset#>,<scale>,<precision>,<assetname>).
  (<id>,balance,<tran4#>,<asset#>,-1,acct:<acct1>).
  (<id>,balance,<tran4#>,<asset2#>,<amount2>acct:<acct2>).
  ...
  (<id>,balance,<tran4#>,<assetN#>,<amountN>,acct:<acctN>).
  
  Note that the balance for the new asset is "-1". Like loom, the sum
  of all balances for an <asset#> add up to -1. A negative balance
  means that the owner is the issuer (except negative balances in the
  usage token can exist during registration). I haven't worked out the
  process to switch issuer ownership.

  If the /asset/<asset#> does not exist, /assetname/<assetname> does
  not exist, <tran4#> is greater than /account/<id>/last, and the
  customer has properly subtracted the createasset fees from the
  balances in /account/<id>/balance/<acctN>, then bank adds
  <asset#>=(<id>,asset,<asset#>,<scale>,<precision>,<assetname>) to
  /asset/, adds <assetname>=<asset#> to /assetname/, and returns:

(<bankid>,affirm,(<id>,asset,<asset#>,<assetname>)).
  (<bankid>,balance,<tran4#>,<asset#>,<amount>,acct:<acct1>).
  (<bankid>,balance,<tran4#>,<asset2#>,<amount2>acct:<acct2>).
  ...
  (<bankid>,balance,<tran4#>,<assetN#>,<amountN>,acct:<acctN>)

  Otherwise, bank returns:

(<bankid>,failed,(<id>,asset,<asset#>,<assetname>),reason:<reason>)


Get outbox
----------

  If customer encounters an outbox hash mismatch, customer can send:

(<id>,getoutbox,<request#>)

  Bank compares <request#> to /account/<id>/lastrequest. If <request#>
  is greater, bank sets /account/<id>/lastrequest to <request#>. Then,
  if the <id> exists, bank returns:

(<bankid>,affirm,(<id>,outbox,<request#>)).
  (<id>,spend,<tran#>,<id2>,<asset#>,<amount>,note:<note>,acct:<name>).
  (<id>,note,<re#>,<id2>,re:<re2#>,note:<note>).
  ...
  (<bankid>,outboxhash,<tran#>,<hash>)

  Otherwise, bank returns:

(<bankid>,failed,(<id>,getoutbox,<request#>),reason:<reason>)


Get balance
-----------

  If the customer loses track of a balance, customer can send:

(<id>,getbalance,<request#>,acct:<acct>)

  <acct> can be "*" to return balances of all accounts.
  Bank compares <request#> to /account/<id>/lastrequest. If <request#>
  is greater, bank sets /account/<id>/lastrequest to <request#>. Then,
  if the <id> exists, bank returns:

(<id>,balance,<tran#>,<asset#>,<amount>,acct:<acct>)...

  Otherwise, bank returns:

(<bankid>,failed,(<id>,getbalance,<request#>,acct:<acct>),reason:<reason>)
