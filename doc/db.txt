setup.php defines the $dbdir, which is the base of the database in the
file system. Here's how the bank directory is structured.

Items in angle brackets are variables
Items not in angle brackets are literals
"--" comment to the end of the line
<dir>/ is a directory
<key>=<value> is a file named <key> with contents <value>
Items whose names end with "#" are sequence numbers.
name:<item> denotes an optional item, passed by position or name
Items in parens  are signed. Signature omitted here.

$dbdir/
  time=(<bankid>,time,<time#>)  -- The global timestamp
  privkey=<privkey>   -- the private key. Maybe this shouldn't be in
                      -- the database, so it doesn't get backed up,
                      -- But once we have a stand-alone server, it
                      -- will need a passphrase to use
  bankid=(<bankid>bankid,<bankid>)      -- The id of the private key
  tokenid=(<bankid>,tokenid,<tokenid>)  -- The assetid of the usage token asset
  regfee=(<bankid>,regfee,<time#>,<tokenid>,<amount>)
                   -- Usage tokens paid for registration
                   -- default: 10 (pubkey/<id> (2),
                                  account/<id>/(time, last, req, outboxhash),
                                  and a few for good luck)
  tranfee=(<bankid>,tranfee,<bankid>,<time#>,<tokenid>,<amount>)
                   -- Usage tokens paid for a transaction.
                   -- Returned when the transaction completes.
                   -- Given to recipient when he rejects a spend (anti-spam)
                   -- Default: 2 (inbox & outbox entry)
  fee/  -- permanent fees, paid for transactions of the given type
        -- Default: none
    spend=(<bankid>,fee|spend,<fee#>,<assetid>,<amount>)[...]
    selfspend=(<bankid>,fee|spend,<fee#>,<assetid>,<amount>)[...]
    createasset=(<bankid>,fee|createasset,<fee#>,<assetid>,<amount>)[...]
  pubkey/  -- for fast lookup. Must verify that <id> = hash(<pubkey>)
    <id>=<pubkey>
  pubkeysig/
    <id>=(<bankid>,@register,(<id>,register,<bankid>,<pubkey>,name=<name>))
  asset/ -- Where the asset types are stored
    <assetid>=(<bankid>,@asset,(<id>,asset,<bankid>,<assetid>,<scale>,<precision>,<assetname>))
        -- The assetid is the sha1 hash of a comma-separated
        -- concatenation of <id>,<scale>,<precision>,<assetname>
        -- This makes an assetid impossible to forge, though there
        -- can be multiple assets with the same name. Customer beware.
        -- Note that because the assetid is unique, it can cross bank boundaries.
  account/
    <id>/
      time=<time#>  -- 0 when no outstanding transaction, or the
                       <time#> for the next transaction. Will contain
                       <time#>,<time2#> after an "inbox" query.
      last=<time#>  -- The last used value of /account/<id>/time
      req=<req#>    -- starts at 0. New requests must have a higher number
      balance/
        <acct>/  -- "main" is the default acct name
          <assetid>=(<bankid>,@balance,(<id>,balance,<bankid>,<time#>,<assetid>,<amount>,acct:<acct>))
      outbox/
        <time2#>=(<bankid>,@spend,(<id>,spend,<bankid>,<time2#>,<id2>,<assetid2>,<amount2>,note:<note2>,acct:<acct2>)).
                 (<bankid>,@tranfee,(<id>,tranfee,<bankid>,<time2#>,<tokenid>,<amount2fee>))
        <time3#>=(<bankid>,@spend,(<id>,spend,<bankid>,<time3#>,<id3>,<assetid3>,<amount3>,note:<note3>,acct:<acct3>)).
                 (<bankid>,@tranfee,(<id>,tranfee,<bankid>,<time3#>,<tokenid>,<amount3fee>))
      outboxhash=(<bankid>,@outboxhash,(<id>,outboxhash,<bankid>,<time#>,<hash>))
      inbox/
        <time5#>=(<bankid>,inbox,<time5#>,(<id2>,spend|accept,<bankid>,<time2#>,<id>,note:<note22>))
        <time6#>=(<bankid>,inbox,<time6#>,(<id3>,spend|reject,<bankid>,<time3#>,<id>,note:<note32>))
        <time7#>=(<bankid>,inbox,<time7#>,(<id4>,spend,<bankid>,<time4#>,<id>,<assetid4>,<amount4>,note:<note4>)).
                 (<bankid>,@tranfee,(<id>,tranfee,<bankid>,<time4#>,<tokenid>,<amount4fee>))


=== Transactions ===

Note that <bankid> is sent in almost all transactions. This guarantees
that the request is actually meant for that bank. It also makes it
easy to notice if somebody steals the machine, but not the bank's
private key passphrase. They will be able to resign all the database
contents, but since all the customer-signed data contains the original
bankid, a customer will notice the change, and be able to prove it.
The bank checks, for all request, that the <bankid> sent matches. I
won't repeat this requirement below.


Get bankid
----------
  Customer sends:

(<id>,bankid,<pubkey>)

  If <id> is the public key ID for <pubkey>, bank returns:

(<bankid>,@register,(<bankid>,register,<bankid>,<pubkey>,name=<name>))

  The <bankid> is required for the other requests, and the bank's
  public key, to validate them. So a new customer will need to do this
  first.

  If there's a mismatch, bank returns:

(<bankid>,failed,(<id>,bankid,<pubkey>),errcode:<errcode>,reason:<reason>)


Create account
--------------

  Customer sends:

(<id>,register,<bankid>,<pubkey>,name=<name>)

  If the id is new, matches the pubkey, the <bankid> is correct, the
  signature is OK, and the customer has enough usage tokens in his
  inbox (spending usage tokens to a new <id> is how the account
  directory is actually created), bank adds a negative spend for the
  registration tokens to customer's inbox, and responds with:

(<bankid>,@register,(<id>,register,<bankid>,<pubkey>,name=<name>))

  This is the first time the bank will have seen the customer's
  pubkey.  The parsing code notices these "id" messages, and verifies
  pubkey if unknown, before using it to verify the registration
  message itself.  Customer will need to process his inbox to transfer
  his introduction tokens, and the bank's charges against them, to his
  balance. Banks can choose to put negative spends in your inbox to
  charge periodic fees. You usually won't be able to spend an asset
  to anyone but the asset issuer until you pay those fees. Banks can
  also choose to allow negative spends from any customer to
  another. This is a request for money, and can be denied like any
  other spend.

(<bankid>,failed,(<id>,register,<pubkey>),errcode:<errcode>,reason:<reason>)

  Note that pubkeys bigger than 4096 bits won't be accepted. Really
  big keys are a good way to DOS attack the server.


Look up pubkey
--------------

  Customer sends:

(<id>,id,<bankid>,<id2>)

  Use 0 for <id2> to look up the bank's key.
  If <id2> is registered, bank responds with:

(<bankid>,@register,(<id2>,register,<bankid>,<pubkey>,name=<name>))

  If there is no such id, bank responds with:

(<bankid>,failed,(<id>,id,<bankid>,<id2>),errcode:<errcode>,reason:<reason>)

  Note that only registered customers can ask for another customer's
  public key. Otherwise, the bank won't know the public key with which
  to validate the request.


Get Req
-------

  Customer sends:

(<id>,getreq,<bankid>)

  Bank returns:

(<bankid>,req,<id>,<req#>)

  Note that this request can be replayed. The customer needs to have
  some way of getting back in sync for requests. This is it.  It makes
  no changes to the server database, just returns the customer's most
  recent request <req#>.


Get timestamp
-------------

  Customer sends:

(<id>,gettime,<bankid>,<req#>)

  Bank compares <req#> to /accounts/<id>/req. If <req#> is greater,
  bank sets /account/<id>/req to <req#>, increments /time to <time#>,
  sets /account/<id>/time to <time#>, and returns:

(<bankid>,gettime,<id>,<time#>)

  Otherwise, bank returns:

(<bankid>,failed,(<id>,gettime,<bankid>,<req#>),errcode:<errcode>,reason:<reason>)

  Note that this always creates a new <time#>, larger than any
  timestamp in the bank. If the cusomter didn't use the last <time#>
  returned from this request, it is overwritten, and can no longer be
  used.

Get fees
--------

  Customer sends:

(<id>,getfees,<bankid>,<req#>,operation=<operation>)

  Bank compares <req#> to /account/<id>/req. If <req#>
  is greater, bank sets /account/<id>/req to <req#>,
  increments /time to <time#>, and returns /regfeesig,
  /tranfeesig, and /feesig/<operation>, or all feesig
  items if operation is not included.

(<bankid>regfee,<time#>,0,<amount>).
  (<bankid>,tranfee,<time2#>,0,<amount>).
  (<bankid>,fee|<operation>,<time3#>,<assetid>,<amount>).
  (<bankid>,fee|<operation2>,<time4#>,assetid2>,<amount2>).
  ...
  (<bankid>,fee|<operationN>,<timeN#>,<assetidN>,<amountN>)

  Otherwise, bank returns:

(<bankid>,failed,(<id>,getfees,<bankid>,<req#>,<operation>),errcode:<errcode>,reason:<reason>)


Spend
-----

  Customer sends the following. Second and subsequent balance items
  are for the fee assets. Customer can pick whatever accounts he likes
  for the fees to be taken from. The bank figures out if it can make
  it work.

(<id>,spend,<bankid>,<time#>,<id2>,<assetid>,<amount>,note:<note>>).
  (<id>,tranfee,<bankid>,<time#>,<tokenid>,<amount2fee>).
  (<id>,balance,<bankid>,<time#>,<assetid>,<amount>,acct:<acct>).
  (<id>,balance,<bankid>,<time#>,<assetid2>,<amount2>,acct:<acct2>).
  ...
  (<id>,balance,<bankid>,<time#>,<assetidN>,<amountN>,acct:<acctN>).
  (<id>,outboxhash,<bankid>,<time#>,<outboxhash>)

  Bank checks that the <time#> is equal to /account/<id>/time, that
  the balances match (after subtracting the spend amount fees), and
  that the hash of all the outbox entries (after adding the new one),
  sorted numerically by <time#>, match what the customer sent. If they
  match, bank sets /account/<id>/time to 0, stores the spend in
  /account/<id>/outbox/<time#> and /account/<id2>/inbox/<time#>, sets
  the /account/<id>/balance/<acct>/<assetid> to the customer's balance
  items, updates /account/<id>/hash with the customer's hash item, and
  sends:

(<bankid>,@spend,(<id>,spend,<time#>,<id2>,<bankid>,<assetid>,<amount>,note:<note>,acct:<acct>)).
  (<bankid>,@tranfee,(<id>,tranfee,<bankid>,<time#>,<tokenid>,<amount2fee>)).
  (<bankid>,@balance,(<id>,balance,<time#>,<bankid>,<assetid>,<amount>,acct:<acct>)).
  (<bankid>,@balance,(<id>,balance,<time#>,<bankid>,assetid2>,<amount2>,acct:<acct2>)).
  ...
  (<bankid>,@balance,(<id>,balance,<time#>,<bankid>,<assetidN>,<amountN>,acct:<acctN>)).
  (<bankid>,@outboxhash,(<id>,outboxhash,<time#>,<bankid>,<hash>))

If they don't match, bank returns:

(<bankid>,failed,(<id>,spend,<bankid>,<time#>,<id2>,<assetid>,<amount>,note:<note>,acct:<acct>),errcode:<errcode>,reason:<reason>)

  If the bank charges non-refunable fees for spends, they must be
  included with the customer's spend message, and they will be
  included in the return message, signed with the same timestamp as
  the customer's spend message.

  The refundable fees are stored in the outbox and included in the
  bank response in case they change between the time the spend is
  initiated and when it is closed. Note that the bank does NOT credit
  its own account with the refundable fees. Those are left in the
  outbox, pending acceptance or rejection of the spend. If accepted,
  the fees are credited back to the customer account. If the recipient
  rejects, they are credited to his account at rejection time. Hence,
  auditing the transaction fee asset requires looking at accounts,
  outbox items, and inbox items. spend|reject inbox items cancel out
  the fees in the corresponding outbox item. spend_accept inbox items
  do not.

Query Inbox
------------

  Customer sends:

(<id>,getinbox,<bankid>,<req#>)

  Bank compares <req#> to /account/<id>/req. If <req#>
  is greater, bank sets /account/<id>/req to <req#> and
  responds with contents of /account/<id>/inbox/, separated by
  periods, plus two timestamps:

(<bankid>,@getinbox,(<id>,getinbox,<bankid>,<req#>).
  (<bankid>,inbox,<time6#>,(<id2>,spend|accept,<bankid>,<time2#>,note:<note22>)).
  (<bankid>,inbox,<time7#>,(<id3>,spend|reject,<bankid>,<time3#>,note:<note32>)).
  (<bankid>,inbox,<time8#>,(<id4>,spend,<bankid>,<time4#>,note:<note4>)).
  (<bankid>,@tranfee,(<id4>,tranfee,<bankid>,<time4#>,<tokenid>,<amount4fee>)).
  (<bankid>,inbox,<time9#>,(<id5>,spend,<bankid>,time5#>,note:<note5>)).
  (<bankid>,@tranfee,(<id5>,tranfee,<bankid>,<time5#>,<tokenid>,<amount5fee>)).
  (<bankid>,gettime,<id>,<time10#>).
  (<bankid>,gettime,<id>,<time11#>)

  Otherwise, bank sends:

(<bankid>,failed,(<id>,inbox,<bankid>,<req#>),errcode:<errcode>,reason:<reason>)

  The two new timestamps ("gettime" messages) are to use for
  processing the inbox, and for doing a spend. The customer doesn't
  have to do either, but he will often want to. The bank will not
  allow a spend to be done if there are any inbox entries with a
  bank-signed timestamp less than /account/<id>/last. This forces
  customers to complete inbox transactions, and be in sync with the
  bank about their balances and outbox contents, if they want to be
  able to do spends.

Process Inbox
-------------

  Customer sends:

(<id>,processinbox,<bankid>,<time11#>,<time6#>|<time7#>|<time8#>|<time9#>).
  (<id>,spend|accept,<bankid>,<id4>,<time4#>,note:<note42>).
  (<id>,spend|reject,<bankid,<id5>,<time5#>,note:<note52>).
  (<id>,balance,<bankid>,<time11#>,<assetid>,<amount>,acct:<acct>).
  (<id>,balance,<bankid>,<time11#>,assetid2>,<amount2>,acct:<acct2>).
  ...
  (<id>,balance,<bankid>,<time11#>,<assetidN>,<amount3>,acct:<acctN>).
  (<id>,outboxhash,<bankid>,<time11#>,<hash>)

Bank compares <time11#> to /account/<id>/time. If it's the same. Bank
processes the requested inbox transactions, and compares the result to
the balances and outboxhash sent by customer. If correct, bank sets
/account/<id>/last to <time11#>, sets /account/<id>/time to 0, removes
the transaction from /account/<id>/inbox/, removes completed
transactions from /account/<id>/outbox/, signs and adds spend|accept
and spend|reject items to the other customers' inboxes, updates the
/account/<id>/balance/<acctN>/<assetidN> with the balances the
customer sent, updates /account/<id>/outboxhash with the outboxhash
item the customer sent, and sends back:

(<bankid,@processinbox,(<id>,processinbox,<bankid>,<time11#>,<time7#>|<time8#>|<time9#>).
  (<bankid>,@spend|accept,(<id>,spend|accept,<bankid>,<id4>,<time4#>,note:<note42>)).
  (<bankid,@spend|reject,(<id>,spend|reject,<bankid,<id5>,<time5#>,note:<note52>)).
  (<bankid>,@balance,(<id>,balance,<bankid>,<time11#>,<assetid>,<amount>,acct:<acct>)).
  (<bankid>,@balance,(<id>,balance,<bankid>,time11#>,assetid2>,<amount2>,acct:<acct2>)).
  ...
  (<bankid>,@balance,(<id>,balance,<bankid>,<time11#>,<assetidN>,<amount3>,acct:<acctN>)).
  (<bankid>,@outboxhash,(<id>,outboxhash,<bankid>,<time11#>,<hash>))

  Otherwise, bank returns:

(<bankid>,failed,(<id>,processinbox,<bankid>,<time11#>|<time6#>|<time7#>|<time8#>|<time9#>),errcode:<errcode>,reason:<reason>)

This is the most complicated function in the system. It has to deal
with two kinds of inbox items. The first is spontaneous spends from
another customer. These get deposited in your account if you
accept. Whether accepted or rejected gets put in the other guys inbox,
where it becomes the second type of inbox item. These acknowledge
earlier spends. When you process one of them, it and the corresponding
outbox item can be removed, forever.

Note that the customer decides which <acct> names will get the spends
and the usage token refunds by where he specifies the balances in the
"balance" items. The bank only verifies that the assets can be
distributed as the customer requested.

Rejected spends credit the usage tokens to the recipient, not the
spender. This discourages spam, even in an otherwise free bank.


Lookup asset
------------

  Customer sends:

(<id>,getasset,<req#>,<bankid>,<assetid>)

  Bank compares <req#> to /account/<id>/req. If <req#>
  is greater, bank sets /account/<id>/req to <req#>. Then,
  if <assetid> exists in /asset, bank returns:

(<bankid>,@asset,(<issuerid>,asset,<bankid>,<assetid>,<assetname>))

  Otherwise, bank returns:

(<bankid>,failed,(<id>,getasset,<bankid>,<assetid>,<random>),errcode:<errcode>,reason:<reason>)


Create asset
------------

  Customer sends:

(<id>,asset,<bankid>,<assetid>,<scale>,<precision>,<assetname>).
  (<id>,balance,<time4#>,<bankid>,<assetid>,-1,acct:<acct1>).
  (<id>,balance,<time4#>,<bankid>,assetid2>,<amount2>acct:<acct2>).
  ...
  (<id>,balance,<time4#>,<bankid>,<assetidN>,<amountN>,acct:<acctN>).
  
  Note that the balance for the new asset is "-1". Like loom, the sum
  of all balances for an <assetid> add up to -1. A negative balance
  means that the owner is the issuer. I haven't worked out the process
  to switch issuer ownership.

  If <assetid> is the hash of <id><scale><precision><assetname>,
  /asset/<assetid> does not exist, <time4#> is equal to
  /account/<id>/time, and the customer has properly subtracted the
  createasset fees from the balances in /account/<id>/balance/<acctN>
  (including a balance of -1 for the new asset), then bank adds
  <assetid>=(<id>,asset,<assetid>,<scale>,<precision>,<assetname>) to
  /asset/, sets /account/<id>/last to <time4#>, clears
  /account/<id>/time, and returns:

(<bankid>,@asset,(<id>,asset,<bankid>,<assetid>,<assetname>)).
  (<bankid>,@balance,(<id>,balance,<time4#>,<bankid>,<assetid>,-1,acct:<acct1>)).
  (<bankid>,@balance,(<id>,balance,<time4#>,<bankid>,assetid2>,<amount2>acct:<acct2>)).
  ...
  (<bankid>,@balance,(<id>,balance,<time4#>,<bankid>,assetidN>,<amountN>acct:<acctN>)).

  Otherwise, bank returns:

(<bankid>,failed,(<id>,asset,<bankid>,<assetid>,<assetname>),errcode:<errcode>,reason:<reason>)


Get outbox
----------

  If customer needs to get back in sync with his outbox, he can send:

(<id>,getoutbox,<bankid>,req#>)

  Bank compares <req#> to /account/<id>/req. If <req#>
  is greater, bank sets /account/<id>/req to <req#>. Then,
  if the <id> exists, bank returns:

(<bankid>,@getoutbox,(<id>,getoutbox,<bankid>,<req#>).
  (<bankid>,@spend,(<id>,spend,<time2#>,<id2>,<bankid>,<assetid2>,<amount2>,note:<note2>,acct:<acct2>))
  (<bankid>,@spend,<id>,spend,<time3#>,<id3>,<bankid>,<assetid3>,<amount3>,note:<note3>,acct:<acct3>))
  ...
  (<bankid>,@outboxhash,(<id>,outboxhash,<time#>,<bankid>,<hash>))

  Otherwise, bank returns:

(<bankid>,failed,(<id>,getoutbox,<bankid>,req#>),errcode:<errcode>,reason:<reason>)


Get balance
-----------

  If the customer loses track of a balance, customer can send:

(<id>,getbalance,<req#>,<bankid>,acct:<acct>,assetid:<assetid>)

  Bank compares <req#> to /account/<id>/req. If <req#> is greater,
  bank sets /account/<id>/req to <req#>.  Then bank returns
  information about the specified <acct>s and <assetid>s If acct is
  not specified then information about all accounts is returned. If
  assetid is not specified, then information about all assetids is
  returned.

(<bankid>,@balance,(<id>,balance,<bankid>,time#>,<assetid>,<amount>,acct:<acct>))...

  Otherwise, bank returns:

(<bankid>,failed,(<id>,getbalance,<bankid>,<req#>,acct:<acct>,assetid:<assetid>),errcode:<errcode>,reason:<reason>)


Switching Asset Issuance
------------------------

TO DO.


// Copyright 2008 Bill St. Clair
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions
// and limitations under the License.
