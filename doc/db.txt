setup.php defines the $dbdir, which is the base of the database in the
file system. Here's how the bank directory is structured.

Items in angle brackets are variables
Items not in angle brackets are literals
"--" comment to the end of the line
<dir>/ is a directory
<key>=<value> is a file named <key> with contents <value>
Items whose names end with "#" are sequence numbers.
name:<item> denotes an optional item, passed by position or name
Items in parens  are signed. Signature omitted here.

$dbdir/
  time=<time#>  -- The global timestamp
  privkey=<privkey>   -- the private key. Maybe this shouldn't be in
                      -- the database, so it doesn't get backed up.
  bankid=<bankid>  -- The id of the private key
  regfee=<regfee>  -- Usage tokens paid for registration
                   -- default: 10 (2 each for /pubkey & /pubkeysig,
                   --              <id>, time#, balance, outbox, inbox,
                   --              and one bonus token)
  )
  regfeesig=(<bankid>,regfee,<fee#>,0,<amount>)
  tranfee=<tranfee>  -- Usage tokens paid for a transaction.
                      -- Returned when the transaction completes.
                      -- Default: 2 (inbox & outbox entry)
  tranfeesig=(<bankid>,tranfee,<fee#>,0,<amount>)
  fee/  -- permanent fees, paid for transactions of the given type
        -- Default: none
    spend=<assetid>:<amount>[.<assetid>:<amount>...]
    note=<assetid>:<amount>[.<assetid>:<amount>...]
    createasset=<assetid>:<amount>[.<assetid>:<amount>...]
  feesig/
    spend=(<bankid>,fee|spend,<fee#>,<assetid>,<amount>)[...]
    note=(<bankid>,fee|note,<fee#>,<assetid>,<amount>)[...]
    createasset=(<bankid>,fee|createasset,<fee#>,<assetid>,<amount>)[...]
  pubkey/
    <id>=<pubkey>
  pubkeysig/
    <id>=(<id>,pubkey,<pubkey>,name>)
  tokenid=<tokenid>  -- The assetid of the usage token asset
  asset/ -- Where the asset types are stored
    <assetid>=(<id>,asset,<assetid>,<scale>,<precision>,<assetname>)
        -- The assetid is the sha1 hash of a comma-separated
        -- concatenation of <id>,<scale>,<precision>,<assetname>
        -- This makes an assetid impossible to forge, though there
        -- can be multiple assets with the same name. Customer beware.
        -- Note that because the assetid is unique, it can cross bank boundaries.
  account/
    <id>/
      time=<time#>  -- 0 when no outstanding transaction, or the <time#> that must be on it
      last=<time#>  -- The last used value of /account/<id>/time
      req=<req#>    -- starts at 0. New requests must have a higher number
      balance/
        <name>/  -- "main" is the default balance name
          <assetid>=(<id>,balance,<time#>,<assetid>,<amount>,acct:<acct>)
      outbox/
        <time2#>=(<id>,spend,<time2#>,<id2>,assetid2>,<amount2>,note:<note2>,acct:<acct2>)
        <time3#>=(<id>,spend,<time3#>,<id3>,<assetid3>,<amount3>,note:<note3>,acct:<acct3>)
      outboxhash=(<id>,outboxhash,<time#>,<hash>)
      inbox/
        <time2#>=(<id2>,spend|accept,<time2#>,note:<note22>,acct:<acct2>)
        <time3#>=(<id3>,spend|reject,<time3#>,note:<note32>)
        <time4#>=(<id4>,spend,<time4#>,note:<note4>)

=== Transactions ===


Look up pubkey
--------------

  Customer sends:

(<id>,id,<id2>)

  Use 0 for <id2> to look up the bank's key.
  If there is such an id registered, bank responds with:

(<id2>,register,<pubkey>,name=<name>)

  If there is no such id, bank responds with:

(<bankid>,failed,(<id>,id,<id2>),reason:<reason>)

  A note about looking up the bank's public key. It can only be done
  by registered customers. If an unregistered customer sends
  (<id>,id,0), the <id> will be unknown, so the signature verification
  of the message will fail.


Create account
--------------

  Customer sends:

(<id>,register,<pubkey>,name=<name>)

  If the id is new, matches the pubkey, the signature is OK, and the
  customer has enough usage tokens in his inbox (spending usage tokens
  to a new <id> is how the account directory is actually created),
  bank adds a negative spend for the registration tokens to customer's
  inbox, and responds with:

(<bankid>,register,<bank_pubkey>,name=<bankname>)

  This is the first time the bank will have seen the customer's
  pubkey.  The parsing code notices these "id" messages, and verifies
  pubkey if unknown, before using it to verify the registration
  message itself.  Customer will need to process his inbox to transfer
  his introduction tokens, and the bank's charges against them, to his
  balance. Banks can choose to put negative spends in your inbox to
  charge periodic fees. You usually won't be able to spend an asset
  to anyone but the asset issuer until you pay those fees. Banks can
  also choose to allow negative spends from any customer to
  another. This is a request for money, and can be denied like any
  other spend.

(<bankid>,failed,(<id>,register,<pubkey>),reason:<reason>)

  Note that pubkeys bigger than 4096 bits won't be accepted. Really
  big keys are a good way to DOS attack the server.

  Note that the customer won't be able to verify the signature on the
  failed message, since he doesn't know the bank's public key, and
  can't get it until he has successfully completed his registration.


Get Req
-------

  Customer sends:

(<id>,getreq,<random>)

  Bank sends:

(<bankid>,req,<req#>)

  Note that this request can be replayed. The customer needs to have
  some way of getting back in sync for requests. This is it.
  It makes no changes to the server database, just returns the
  customer's most recent request <req#>.


Get timestamp
-------------

  Customer sends:

(<id>,time,<req#>)

  Bank compares <req#> to /accounts/<id>/req. If <req#> is greater,
  bank sets /account/<id>/req to <req#>, increments /time to <time#>,
  sets /account/<id>/time to <time#>, and returns:

(<bankid>,time,<time#>)

  Otherwise, bank returns

(<bankid>,failed,(<id>,time,<req#>),reason:<reason>)

  Note that this always creates a new <time#>, larger than any
  timestamp in the bank. If the cusomter didn't use the last <time#>
  returned from this request, it is overwritten, and can no longer be
  used.

Get fees
--------

  Customer sends:

(<id>,getfees,<operation>,<req#>)

  <operation> can be "*" to return all fees.
  Bank compares <req#> to /account/<id>/req. If <req#>
  is greater, bank sets /account/<id>/req to <req#>,
  increments /time to <time#>, and returns /regfeesig,
  /tranfeesig, and /feesig/<operation>:

(<bankid>regfee,<time#>,0,<amount>).
  (<bankid>,tranfee,<time2#>,0,<amount>).
  (<bankid>,fee|<operation>,<time3#>,<assetid>,<amount>).
  (<bankid>,fee|<operation2>,<time4#>,assetid2>,<amount2>).
  ...
  (<bankid>,fee|<operationN>,<timeN#>,<assetidN>,<amountN>)

  Otherwise, bank returns:

(<bankid>,failed,(<id>,getfees,<operation>,<req#>),reason:<reason>)


Spend
-----

  Customer sends the following. Second and subsequent balance items
  are for the fee assets. Customer can pick whatever accounts he likes
  for the fees to be taken from. The bank figures out if it can make
  it work.

(<id>,spend,<time#>,<id2>,<assetid>,<amount>,note:<note>,acct:<name>).
  (<id>,balance,<time#>,<assetid>,<amount>,acct:<acct>).
  (<id>,balance,<time#>,assetid2>,<amount2>,acct:<acct2>).
  ...
  (<id>,balance,<time#>,<assetidN>,<amountN>,acct:<acctN>).
  (<id>,outboxhash,<time#>,<outboxhash>)

  Bank checks that the <time#> is equal to /account/<id>/time, that
  the balances match (after subtracting the spend amount fees), and
  that the hash of all the outbox entries (after adding the new one),
  sorted numerically by <time#>, match what the customer sent. If they
  match, bank sets /account/<id>/time to 0, stores the spend in
  /account/<id>/outbox/<time#> and /account/<id2>/inbox/<time#>, sets
  the /account/<id>/balance/<name>/<assetid> to the customer's balance
  items, updates /account/<id>/hash with the customer's hash item, and
  sends:

(<bankid>,spend,<time#>,<id2>,<assetid>,<amount>,note:<note>,acct:<acct>).
  (<bankid>,balance,<time#>,<assetid>,<amount>,acct:<acct>).
  (<bankid>,balance,<time#>,assetid2>,<amount2>,acct:<acct2>).
  ...
  (<bankid>,balance,<time#>,<assetidN>,<amountN>,acct:<acctN>).
  (<bankid>,outboxhash,<time#>,<hash>)

If they don't match, bank returns:

(<bankid>,failed,(<id>,spend,<time#>,<id2>,<assetid>,<amount>,note:<note>,acct:<name>),reason:<reason>).
  (<id>,balance,<time#>,<assetid>,<amount>,acct:<acct>).
  (<id>,outboxhash,<time#>,<hash>)


Query Inbox
------------

  Customer sends:

(<id>,inbox,<req#>)

  Bank compares <req#> to /account/<id>/req. If <req#>
  is greater, bank sets /account/<id>/req to <req#> and
  responds with contents of /account/<id>/inbox/, separated by
  periods:

(<bankid>,affirm,<time6#>,
  (<id>,inbox,<req#>).
  (<id2>,spend,<time2#>,note:<note2>).
  (<id3>,spend,<time3#>,note:<note3>))

  Otherwise, bank sends:

(<bankid>,failed,(<id>,inbox,<req#>),reason=<reason>)

  Note that once the customer has an inbox affirmation, the bank may
  never present an inbox item with an earlier <time#>

Process Inbox
-------------

  Customer sends:

(<id>,processinbox,in1#|in2#|in3#,accts=<acct>|<acct2>).
  (<id>,spend|accept,<id2>,<time2#>,note:<note5>).
  (<id>,spend|reject,<id3>,<time3#>,note:<note6>).
  (<id>,balance,<time4#>,<assetid>,<amount>,acct:<acct>).
  (<id>,balance,<time4#>,assetid2>,<amount2>,acct:<acct2>).
  ...
  (<id>,balance,<time4#>,<assetidN>,<amount3>,acct:<acctN>).
  (<id>,outboxhash,<time4#>,<hash>)

Bank processes the requested inbox transaction2, and compares the
result to the balances and outboxhash sent by customer. If correct,
bank removes the listed transactions from /account/<id>/inbox/,
removes the corresponding transactions from /account/<id>/outbox/,
updates the /account/<id>/balance/<nameN>/<assetidN> with the balances
the customer sent, updates /account/<id>/outboxhash with the
outboxhash item the customer sent, and sends back:

(<bankid,affirm,(<id>,removeinbox,<inbox1#>|<inbox2#>|<inbox3#>)).
  (<bankid>,balance,<time4#>,<assetid>,<amount>,acct:<acct>).
  (<bankid>,balance,<time4#>,assetid2>,<amount2>,acct:<acct2>).
  ...
  (<bankid>,balance,<time4#>,<assetidN>,<amount3>,acct:<acctN>).
  (<bankid>,outboxhash,<time#>,<hash>)

  Otherwise, bank returns:

(<bankid>,failed,(<id>,removeinbox,<time2#>|<time3#>|<time4#>),reason=<reason>)

Note that this doesn't automatically send notice of delivery of
notes. Maybe it should, but probably better to preserve people's
privacy. If you want to know if they saw your note, give them a small
spend. They have to accept or reject it to get it out of their inbox.

Note that <acct2> is included in the "processinbox" message above only
to illustreate the syntax. A destination account for a rejected
spend makes no sense.


Lookup asset
------------

  Customer sends:

(<id>,getasset,<assetid>,<req#>)

  Bank compares <req#> to /account/<id>/req. If <req#>
  is greater, bank sets /account/<id>/req to <req#>. Then,
  if <assetid> exists in /asset, bank returns:

(<bankid>,affirm,(<issuerid>,asset,<assetid>,<assetname>))

  Otherwise, bank returns:

(<bankid>,failed,(<id>,getasset,<assetid>,<random>),reason:<reason>)


Create asset
------------

  Customer sends:

(<id>,asset,<assetid>,<scale>,<precision>,<assetname>).
  (<id>,balance,<time4#>,<assetid>,-1,acct:<acct1>).
  (<id>,balance,<time4#>,assetid2>,<amount2>acct:<acct2>).
  ...
  (<id>,balance,<time4#>,<assetidN>,<amountN>,acct:<acctN>).
  
  Note that the balance for the new asset is "-1". Like loom, the sum
  of all balances for an <assetid> add up to -1. A negative balance
  means that the owner is the issuer (except negative balances in the
  usage token can exist during registration). I haven't worked out the
  process to switch issuer ownership.

  If the /asset/<assetid> does not exist, /assetname/<assetname> does
  not exist, <time4#> is greater than /account/<id>/time, and the
  customer has properly subtracted the createasset fees from the
  balances in /account/<id>/balance/<acctN>, then bank adds
  <assetid>=(<id>,asset,<assetid>,<scale>,<precision>,<assetname>) to
  /asset/, adds <assetname>=<assetid> to /assetname/, and returns:

(<bankid>,affirm,(<id>,asset,<assetid>,<assetname>)).
  (<bankid>,balance,<time4#>,<assetid>,<amount>,acct:<acct1>).
  (<bankid>,balance,<time4#>,assetid2>,<amount2>acct:<acct2>).
  ...
  (<bankid>,balance,<time4#>,<assetidN>,<amountN>,acct:<acctN>)

  Otherwise, bank returns:

(<bankid>,failed,(<id>,asset,<assetid>,<assetname>),reason:<reason>)


Get outbox
----------

  If customer encounters an outbox hash mismatch, customer can send:

(<id>,getoutbox,<req#>)

  Bank compares <req#> to /account/<id>/req. If <req#>
  is greater, bank sets /account/<id>/req to <req#>. Then,
  if the <id> exists, bank returns:

(<bankid>,affirm,(<id>,outbox,<req#>)).
  (<id>,spend,<time#>,<id2>,<assetid>,<amount>,note:<note>,acct:<name>).
  (<id>,note,<re#>,<id2>,re:<re2#>,note:<note>).
  ...
  (<bankid>,outboxhash,<time#>,<hash>)

  Otherwise, bank returns:

(<bankid>,failed,(<id>,getoutbox,<req#>),reason:<reason>)


Get balance
-----------

  If the customer loses track of a balance, customer can send:

(<id>,getbalance,<req#>,acct:<acct>)

  <acct> can be "*" to return balances of all accounts.
  Bank compares <req#> to /account/<id>/req. If <req#>
  is greater, bank sets /account/<id>/req to <req#>. Then,
  if the <id> exists, bank returns:

(<id>,balance,<time#>,<assetid>,<amount>,acct:<acct>)...

  Otherwise, bank returns:

(<bankid>,failed,(<id>,getbalance,<req#>,acct:<acct>),reason:<reason>)

// Copyright 2008 Bill St. Clair
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions
// and limitations under the License.
