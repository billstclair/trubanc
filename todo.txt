Remember the last successful spend or processinbox message and its result, and resend the result if the message is resent. This can heal responses that are lost in transit.

Credit the bank for usage tokens paid for files. Some of this may be already done, but that code needs reviewing.

-----

Encrypt the client<->server messages. SSL could do this, but why bother, when we can easily do it ourselves? Why pay for an SSL certificate and the SSL connection overhead, when you don't have to?

  sent: (<id>,getsessionkey,<bankid>,<reqid>)
  rcvd: (<bankid>,sessionkey,<id>,<pubkey encrypted: [<sessionid>,<sessionkey>]>)

  sent: [<sessionid>,<sessionkey encrypted: message>]
  rcvd: [<sessionid>,<sessionkey encrypted: response>]
           or
        [<sessionid>,unknown]

  sent: [<sessionid>,
         <sessionkey encrypted: (<id>,closesession,<bankid>,<sessionid>)>]
  rcvd: [<sessionid>,
         <sessionkey encrypted:
           (<bankid>,@closesession,(<id>,closesession,<bankid>,<sessionid>))>]

-----

Keep acct and balance hashes. Spend and processinbox become two-stage
processes.  Also, add a count to the outbox hash and the new accthash
and balancehash. Makes it easier to see if something is missing.

account
  <id>
    balance
      <acct>
        accthash=(<bankid>,@accthash,(<id>,accthash,<bankid>,<time>,<count><hash>))
        <assetid>=(<bankid>,@balance,(<id>,balance,<bankid>,<time>,<assetid>,<amount>))
    outbox
      ...
    outboxhash=(<bankid>,@outboxhash,(<id>,outboxhash,<bankid>,<time>,<count>,<hash>))
    balancehash=(<id>,@balancehash,(<bankid>,@balancehash,(<id>,balancehash,<bankid>,<time>,<count>,<hash>)))

The <hash> values for accthash hash the customer 'balance' items,
counting the total number within one <acct>

The <hash> values for balancehash hash the accthash <hash> values and
the outboxhash <hash> value, counting the total number of <acct>
directories, plus one for the outboxhash.

The additional surrounding customer-signed @balancehash is the final kiss:

Spend
=====
1) Customer sends spend, tranfee, balance, accthash, outboxhash, balancehash
2) Bank sends back @spend, @tranfee, @balance, @accthash, @outboxhash, @balancehash
3) Customer sends final @balancehash to commit the transaction.
   or (<id>,@rollback,<bankid>,<time>) to roll it back.
4) Bank returns another level of @balancehash.

processinbox
============
1) Customer sends processinbox, spend|accept, spend|reject, balance,
   accthash, outboxhash, balancehash
2) Bank sends back @processinbox, @spend|accept, @spend|reject, @balance,
   @accthash, @outboxhash, @balancehash
3) Customer sends final @balancehash to commit the transaction.
   or (<id>,rollback,<bankid>,<time>) to roll it back.
4) Bank returns another level of @balancehash.

-----

Remove zero-balance files and credit a usage token. This requires a new message that captures all the files for, e.g., an account, so the customer can't claim a non-zero balance later on for the now missing file.

spend|cancel to take back a spend before the other guy has accepted or rejected it.

Support fees other than usage tokens.

Error codes on $this->failmsg()

$t->SPEND
---------

Right now, spends to the bank are rejected right away.

Alternatives:

1) Accept spends to the bank right away, with no inbox or
outbox. Credit the bank's accounts.

2) Reject spends to the bank, but keep the proferred tokens. This might anger some, but possibly no more than losing tokens when another customer rejects your spend.


Checks and Certificates
-----------------------

Have to keep external spend receipt until expiration date. Check or certificate costs a usage token, which is refunded on expiration. Thank you, Patrick!
