<?PHP

  // client.php
  // A Trubanc client API. Talks the protocol of server.php

require_once "tokens.php";
require_once "ssl.php";
require_once "utility.php";
require_once "parser.php";

class client {

  var $db;
  var $ssl;
  var $t;                       // tokens instance
  var $parser;                  // parser instance
  var $u;                       // utility instance
  var $pubkeydb;

  // Initialized by login() and newuser()
  var $id;
  var $privkey;
  var $pubkey;

  // initialized by setbank() and addbank()
  var $server;
  var $bankid;

  // Set true by getreq()
  var $syncedreq = false;

  var $unpack_reqs_key = 'unpack_reqs';

  // True to make process() print the messages it sends and receives
  var $showprocess = false;

  // Used by newsessionid()
  var $random = false;

  // The last coupon generated by a spend:
  // (<bankid>,couponenvelope,<id>,<encrypted-coupon>)
  var $coupon = false;

  // The last outbox time generated by a spend
  var $lastspendtime = false;

  // $db is an object that does put(key, value), get(key), contents(key),
  // & subdir(subkey), as in fsdb.php
  // $ssl is an object that does the protocol of ssl.php
  function client($db, $ssl=false) {
    $this->db = $db;
    if (!$ssl) $ssl = new ssl();
    $this->ssl = $ssl;
    $this->t = new tokens();
    $this->pubkeydb = new pubkeydb($this, $db->subdir($this->t->PUBKEY));
    $this->parser = new parser($this->pubkeydb, $ssl);
    $this->u = new utility($this->t, $this->parser, $this);
  }

  // API Methods
  // If the return is not specified, it will be false or an error string

  // Create a new user with the given passphrase, error if already there.
  // If $privkey is a string, use that as the private key.
  // If it is an integer, default 3072, create a new private key with that many bits
  // User is logged in when this returns successfully.
  // If $coupon is included, submit it to the bank before creating
  // the account, and error if the bank errors on the coupon.
  function newuser($passphrase, $privkey=3072, $coupon=false) {
    $db = $this->db;
    $t = $this->t;
    $ssl = $this->ssl;

    $this->logout();
    $hash = $this->passphrasehash($passphrase);
    if ($db->get($t->PRIVKEY . "/$hash")) {
        return "Passphrase already has an associated private key";
    }
    if (is_numeric($privkey)) {
      // $privkey is size in bits for new private key
      $privkey = $ssl->make_privkey($privkey, $passphrase);
    }
    $privkeystr = $privkey;
    $privkey = $ssl->load_private_key($privkey, $passphrase);
    if (!$privkey) return "Could not load private key";
    $pubkey = $ssl->privkey_to_pubkey($privkey);
    
    $id = $ssl->pubkey_id($pubkey);
    $db->put($t->PRIVKEY . "/$hash", $privkeystr);
    $db->put($this->pubkeykey($id), trim($pubkey) . "\n");

    $this->id = $id;
    $this->privkey = $privkey;
    $this->pubkey = $pubkey;
    return false;
  }

  function getprivkey($passphrase) {
    $db = $this->db;
    $t = $this->t;

    $hash = $this->passphrasehash($passphrase);
    return $db->GET($t->PRIVKEY . "/$hash");
  }

  // Log in with the given passphrase. Error if no user associated with passphrase.
  function login($passphrase) {
    $db = $this->db;
    $t = $this->t;
    $ssl = $this->ssl;

    $privkey = $this->getprivkey($passphrase);
    if (!$privkey) return "No account for passphrase in database";
    $privkey = $ssl->load_private_key($privkey, $passphrase);
    if (!$privkey) return "Could not load private key";
    $pubkey = $ssl->privkey_to_pubkey($privkey);
    $id = $ssl->pubkey_id($pubkey);

    $this->id = $id;
    $this->privkey = $privkey;
    $this->pubkey = $pubkey;
    return false;
  }

  function login_with_sessionid($sessionid) {
    $passphrase = $this->sessionpassphrase($sessionid);
    if (!$passphrase) return "No passphrase for session";
    $err = $this->login($passphrase);
    if (!$err) $this->syncedreq = true; // no server sync for session login
    return $err;
  }

  // Login, create a new session, and return either
  // an error string or an array containing the sessionid.
  function login_new_session($passphrase) {
    $res = $this->login($passphrase);
    if ($res) return $res;
    return array($this->makesession($passphrase));
  }

  function logout() {
    $ssl = $this->ssl;

    if ($this->id) $this->removesession();

    $this->id = false;
    $privkey = $this->privkey;
    if ($privkey) {
      $this->privkey = false;
      $ssl->free_privkey($privkey);
    }
    $this->bankid = false;
    $this->server = false;
  }

  // All the API methods below require the user to be logged in.
  // $id and $privkey must be set.

  // Return current user ID if logged in, otherwise false.
  function current_user() {
    return $this->privkey ? $this->id : false;
  }

  // Return pubkey of a user, default logged-in user
  function user_pubkey($id=false) {
    $db = $this->db;
    $t = $this->t;

    if (!$id) $id = $this->id;
    if ($id) return $db->get($t->pubkey . "/$id");
    return false;
  }

  function comparebanks($b1, $b2) {
    $t = $this->t;

    return $this->comparearrays($b1, $b2, array($t->NAME, $t->URL));
  }

  // Return all the banks known by the current user:
  // array($t->BANKID => array($t->BANKID => $bankid,
  //                           $t->NAME => $name,
  //                           $t->URL => $url),
  //       ...)
  // $pubkeysig will be blank if the user has no account at the bank.
  function getbanks($all=false) {
    $t = $this->t;
    $db = $this->db;
    $id = $this->id;

    if (!$this->current_user()) return "Not logged in";

    $banks = $db->contents($t->ACCOUNT . "/$id/" . $t->BANK);
    $res = array();
    foreach ($banks as $bankid) {
      $bank = $this->getbank($bankid, $all);
      if ($bank) $res[$bankid] = $bank;
    }

    uasort($res, array('client', 'comparebanks'));

    return $res;
  }

  // Returns  array($t->BANKID => $bankid,
  //                $t->NAME => $name,
  //                $t->URL => $url)
  // or false if it doesn't find the $bankid
  // If $all is true, return the bank even if the current user isn't logged in
  function getbank($bankid, $all=false) {
    $t = $this->t;

    $req = $this->userreq($bankid);
    $bank = false;
    if ($all || !($req === false || $req === '')) {
      $bank = array($t->BANKID => $bankid,
                    $t->NAME => $this->bankprop($t->NAME, $bankid),
                    $t->URL => $this->bankprop($t->URL, $bankid));
    }
    return $bank;
  }

  // Returns true if $url might be a properly-fored URL
  function isurl($url) {
    return (is_string($url) &&
            (substr($url, 0, 5) == "http:" ||
             substr($url, 0, 6) == "https:"));
  }

  // Parse a coupon into bankid & url.
  // Return an error string or false.
  // Sets the $bankid & $url args to the bankid & URL in the coupon.
  function parsecoupon($coupon, &$bankid, &$url) {
    $t = $this->t;
    $db = $this->db;
    $parser = $this->parser;

    if (!is_string($coupon)) return 'Coupon not a string';
    $parse = $parser->tokenize($coupon);
    $items = array();
    foreach ($parse as $item) $items[] = $item;
    if ($items[0] != '(') return "Message doesn't start with left paren";
    $bankid = $items[1];
    if (!$this->is_id($bankid)) return "Coupon bankid not an id";
    if ($items[2] != ',') return "Coupon missing comma 1";
    if ($items[3] != $t->COUPON) return "Coupon isn't a coupon message";
    if ($items[4] != ',') return "Coupon missing comma 2";
    $url = $items[5];
    if (!$this->isurl($url)) return "Coupon url isn't a url: $url";
    return false;
  }

  // Verify that a message is a valid coupon.
  // Check that it is actually signed by the bank that it
  // claims to be from.
  // Ask the bank whether a coupon of that number exists.
  function verifycoupon($coupon, $bankid, $url) {
    $t = $this->t;
    $parser = $this->parser;

    $err = $this->verifybank($url, $bankid);
    if ($err) return "verifycoupon: $err";
    $args = $this->unpack_bankmsg($coupon, $t->COUPON, $bankid);
    if (is_string($args)) return $args;

    $coupon_number = $args[$t->COUPON];
    if (!$this->is_coupon_number($coupon_number)) {
      return "Malformed coupon number: $coupon_number";
    }
    $msg = "(0," . $t->BANKID . ",0,$coupon_number):0";
    $server = new serverproxy($url, $this);
    $msg = $server->process($msg);

    $reqs = $parser->parse($msg);
    if (!$reqs) return "verifycoupon: " . $parser->errmsg;
    if (count($reqs) != 2) return "verifycoupon: expected 2 messages from bank";
    $args = $this->match_bankreq($reqs[0], $t->REGISTER, $bankid);
    if (is_string($args)) return "verifycoupon: $args";
    $args = $this->match_bankreq($reqs[1], $t->COUPONNUMBERHASH, $bankid);
    if (is_string($args)) return "$args";

    return false;
  }

  // Verify that a bank matches its URL.
  // Add the bank to our database if it's not there already
  // Set $id arg to $bankid, if false, or
  // compare it to the bankid returned from URL.
  function verifybank($url, &$id) {
    $t = $this->t;
    $db = $this->db;

    if (!$this->isurl($url)) return "Not a URL: $url";

    // Hash the URL to ensure its name will work as a file name
    $urlhash = sha1($url);
    $urlkey = $t->BANK . '/' . $t->BANKID;
    $bankid = $db->get("$urlkey/$urlhash");
    if ($bankid) {
      if ($id && $id != $bankid) return "verifybank: id <> bankid";
      if (!$id) $id = $bankid;
    } else {
      $u = $this->u;
      $ssl = $this->ssl;
      $parser = $this->parser;

      $msg = '(0,' . $t->BANKID . ',0):0';
      $server = new serverproxy($url, $this);
      $msg = $server->process($msg);
      $savebankid = $this->bankid;
      $this->bankid = $bankid;
      $args = $u->match_message($msg);
      $this->bankid = $savebankid;
      if (is_string($args)) {
        return "verifybank: Bank's bankid response error: $args";
      }
      $bankid = $args[$t->CUSTOMER];
      if ($args[$t->REQUEST] != $t->REGISTER) {
        return "Bank URL unresponsive or not a Trubanc server";
      }
      if ($bankid != $args[$t->BANKID]) {
        return "Bank's register message malformed";
      }
      if (!$id) $id = $bankid;
      elseif ($bankid != $id) return "Bankid different than expected";
      $pubkey = $args[$t->PUBKEY];
      $name = $args[$t->NAME];
      if ($ssl->pubkey_id($pubkey) != $bankid) {
        return "verifybank: Bank's id doesn't match its public key";
      }
      if ($id && $id != $bankid) return "verifybank: id <> bankid";
      if (!$id) $id = $bankid;
      $ourl = $this->bankprop($t->URL, $bankid);
      if (!$ourl) {
        // Initialize the bank in the database
        $db->put("$urlkey/$urlhash", $bankid);
        $db->put($this->bankkey($t->URL, $bankid), $url);
        $db->put($this->bankkey($t->NAME, $bankid), $name);
        $db->put($this->pubkeykey($bankid), trim($pubkey) . "\n");
      }
    }

    return false;
  }

  // Add a bank with the given $url to the database.
  // $url can be a coupon to redeem that with registration.
  // No error, but does nothing, if the bank is already there.
  // If the bank is NOT already there, registers with the given $name and $coupons.
  // If registration fails, removes the bank and you'll have to add it again
  // after getting enough usage tokens at the bank to register.
  // Sets the client instance to use this bank until addbank() or setbank()
  // is called to change it.
  // If $couponok is true, does not verify a coupon with the bank before using it.
  function addbank($url, $name='', $couponok=false) {
    $db = $this->db;
    $t = $this->t;

    if (!$this->current_user()) return "Not logged in";

    $bankid = false;
    $realurl = false;
    $coupon = false;
    $err = $this->parsecoupon($url, $bankid, $realurl);
    if ($err) {
      $err = $this->verifybank($url, $bankid);
      if ($err) return $err;
    } else {
      if (!$couponok) {
        $err = $this->verifycoupon($url, $bankid, $realurl);
        if ($err) return "$err";
      }
      $coupon = $url;
    }
    $err = $this->setbank($bankid, false);
    if (!$err) {
      // User already has an account at this bank.
      // Redeem the coupon
      $err = false;
      if ($coupon) $err =$this->redeem($coupon);
      return $err;
    }

    $oldbankid = $this->bankid;
    $oldserver = $this->server;

    $this->bankid = $bankid;
    $url = $this->bankprop($t->URL, $bankid);
    if (!$url) return "URL not stored for verified bank";
    $this->server = new serverproxy($url, $this);
    $err = $this->register($name, $coupon, $bankid);
    if ($err) {
      $db->put($this->userreqkey($bankid), '');
      $this->bankid = false;
      $this->bankid = $oldbankid;
      $this->server = $oldserver;
      return $err;
    }

    return false;
  }

  // Set the bank to the given id.
  // Sets the client instance to use this bank until addbank() or setbank()
  // is called to change it, by setting $this->bankid and $this->server
  function setbank($bankid, $check=true) {
    $db = $this->db;
    $t = $this->t;
    $u = $this->u;

    if (!$this->current_user()) return "Not logged in";

    $url = $this->bankprop($t->URL, $bankid);
    if (!$url) {
      return "Bank not known: $bankid";
    }

    $req = $this->userbankprop($t->REQ, $bankid);
    if ($req === '' || $req === false) {
      return "User not registered at bank";
    }

    $this->bankid = $bankid;
    $server = new serverproxy($url, $this);
    $this->server = $server;

    if ($check) {
      $msg = $this->sendmsg($t->BANKID, $this->pubkey);
      $args = $u->match_message($msg);
      if (is_string($args)) {
        $this->bankid = false;
        return "setbank: Bank's bankid response error: $args";
      }
      if ($bankid != $args[$t->CUSTOMER]) {
        $this->bankid = false;
        return "bankid changed since we last contacted this bank";
      }
      if ($args[$t->REQUEST] != $t->REGISTER ||
          $args[$t->BANKID] != $bankid) {
        $this->bankid = false;
        return "Bank's bankid message wrong: $msg";
      }
    }

    return false;
  }

  // Return current bank if the user is logged in and the bank is set, else false.
  function current_bank() {
    if ($this->current_user() && $this->server) return $this->bankid;
    return false;
  }

  // All the API methods below require the user to be logged and the bank to be set.
  // Do this by calling newuser() or login(), and addbank() or setbank().
  // $this->id, $this->privkey, $this->bankid, & $this->server must be set.

  // Register at the current bank.
  // No error if already registered
  // If not registered, and $coupons is a string or array of strings,
  // assumes the string(s) are coupons, encrypts and signs them,
  // and sends them to the bank with the registration request.
  function register($name='', $coupons=false, $bankid=false) {
    $t = $this->t;
    $u = $this->u;
    $db = $this->db;
    $id = $this->id;
    $ssl = $this->ssl;

    if (!$bankid) {
      $bankid = $this->bankid;
      $server = $this->server;
    } else {
      $url = $this->bankprop($t->URL);
      if (!$url) return "In register: Unknown bankid";
      $server = new serverproxy($url, $this);
    }

    if (!$this->current_bank()) return "In register(): Bank not set";

    // If already registered and we know it, nothing to do
    if ($db->get($this->userbankkey($t->PUBKEYSIG, $bankid) . "/$id")) return false;

    // See if bank already knows us
    // Resist the urge to change this to a call to
    // get_pubkey_from_server. Trust me.
    $msg = $this->custmsg($t->ID, $bankid, $id);
    $msg = $server->process($msg);
    $args = $this->unpack_bankmsg($msg, $t->ATREGISTER);
    if (is_string($args)) {
      // Bank doesn't know us. Register with bank.
      $msg = $this->custmsg($t->REGISTER, $bankid, $this->pubkey($id), $name);
      if ($coupons) {
        if (is_string($coupons)) $coupons = array($coupons);
        $pubkey = $this->pubkeydb->get($bankid);
        if (!$pubkey) return "Can't get bank public key";
        foreach ($coupons as $coupon) {
          $coupon = $ssl->pubkey_encrypt($coupon, $pubkey);
          $msg .= '.' . $this->custmsg($t->COUPONENVELOPE, $bankid, $coupon);
        }
      }
      $msg = $server->process($msg);
      $args = $this->unpack_bankmsg($msg, $t->ATREGISTER);
      if (is_string($args)) return "Registration failed: $args";
    }

    // Didn't fail. Notice registration here
    $args = $args[$t->MSG];
    if ($args[$t->CUSTOMER] != $id ||
        $args[$t->REQUEST] != $t->REGISTER ||
        $args[$t->BANKID] != $bankid) return "Malformed registration message";
    $pubkey = $args[$t->PUBKEY];
    $keyid = $ssl->pubkey_id($pubkey);
    if ($keyid != $id) return "Server's pubkey wrong";
    $db->put($this->userbankkey($t->PUBKEYSIG) . "/$id", $msg);

    return false;
  }

  // Get contacts for the current bank.
  // Contacts are sorted by nickname, name, id
  // Returns an error string or an array of items of the form:
  //
  //   array($t->ID => $id,
  //         $t->NAME => $name,
  //         $t->NICKNAME => $nickname,
  //         $t->NOTE => $note)
  function getcontacts() {
    $t = $this->t;
    $db = $this->db;

    if (!$this->current_bank()) return "In getcontacts(): Bank not set";

    $lock = $db->lock($this->userreqkey());
    $res = $this->getcontacts_internal();
    $db->unlock($lock);

    return $res;
  }

  // General comparison function on array element
  function comparearrays($a1, $a2, $keys, $comparer='strcasecmp') {
    foreach ($keys as $key) {
      $res = $comparer($a1[$key], $a2[$key]);
      if ($res != 0) return $res;
    }
    return 0;
  }

  // For usort in getcontacts_internal
  function comparecontacts($c1, $c2) {
    $t = $this->t;

    return $this->comparearrays
      ($c1, $c2, array($t->NICKNAME, $t->NAME, $t->ID));
  }

  function getcontacts_internal() {
    $t = $this->t;
    $db = $this->db;
    
    $ids = $db->contents($this->contactkey());
    $res = array();
    foreach ($ids as $otherid) {
      $contact = $this->getcontact_internal($otherid, false, false);
      if ($contact) $res[] = $contact;
    }
    usort($res, array("client", "comparecontacts"));
    return $res;
  }

  // Get a contact, by ID.
  // Return:
  //   array($t->ID => $id,
  //         $t->NAME => $name,
  //         $t->NICKNAME => $nickname,
  //         $t->NOTE => $note,
  //         $t->CONTACT => $iscontact)
  // or false, if can't find that contact.
  function getcontact($otherid, $add=false) {
    $t = $this->t;
    $db = $this->db;
    
    if (!$this->current_bank()) return false;

    $lock = $db->lock($this->userreqkey());
    $res = $this->getcontact_internal($otherid, $add);
    $db->unlock($lock);

    return $res;
  }

  function getcontact_internal($otherid, $add=false, $probebank=true) {
    $t = $this->t;
    $db = $this->db;
    
    $pubkeysig = $this->contactprop($otherid, $t->PUBKEYSIG);
    if (!$pubkeysig) {
      if ($add) {
        $this->addcontact_internal($otherid);
        $pubkeysig = $this->contactprop($otherid, $t->PUBKEYSIG);
      } elseif ($probebank) {
        return $this->get_id($otherid);
      }
    }
    if (!$pubkeysig) return false;
    $res = array($t->ID => $otherid,
                 $t->NAME => $this->contactprop($otherid, $t->NAME),
                 $t->NICKNAME => $this->contactprop($otherid, $t->NICKNAME),
                 $t->NOTE => $this->contactprop($otherid, $t->NOTE),
                 $t->CONTACT => true);
    return $res;
  }
  
  // Add a contact to the current bank.
  // If it's already there, change its nickname and note, if included
  function addcontact($otherid, $nickname=false, $note=false) {
    $t = $this->t;
    $db = $this->db;

    $lock = $db->lock($this->userreqkey());
    $res = $this->addcontact_internal($otherid, $nickname, $note);
    $db->unlock($lock);

    return $res;
  }

  function addcontact_internal($otherid, $nickname=false, $note=false) {
    $t = $this->t;
    $db = $this->db;

    $pubkeydb = $this->pubkeydb;
    $bankid = $this->bankid;
    $ssl = $this->ssl;

    if (!$this->current_bank()) return "In addcontact(): Bank not set";

    if ($this->contactprop($otherid, $t->PUBKEYSIG)) {
      if ($nickname) $db->put($this->contactkey($otherid, $t->NICKNAME), $nickname);
      if ($note) $db->put($this->contactkey($otherid, $t->NOTE), $note);
      return false;
    }

    $args = $this->get_id($otherid);
    if (!$args) return "Can't find id at bank: $otherid";
    $msg = $args[$t->MSG];
    $name = $args[$t->NAME];

    if (!$nickname) $nickname = $name ? $name : 'anonymous';
    $db->put($this->contactkey($otherid, $t->NICKNAME), $nickname);
    $db->put($this->contactkey($otherid, $t->NOTE), $note);
    $db->put($this->contactkey($otherid, $t->NAME), $name);
    $db->put($this->contactkey($otherid, $t->PUBKEYSIG), $msg);
  }

  // Delete a contact from the current bank.
  function deletecontact($otherid) {
    $t = $this->t;
    $db = $this->db;

    $lock = $db->lock($this->userreqkey());
    $res = $this->deletecontact_internal($otherid);
    $db->unlock($lock);

    return $res;
  }

  function deletecontact_internal($otherid) {
    $t = $this->t;
    $db = $this->db;

    $key = $this->contactkey($otherid);
    $contents = $db->contents($key);
    foreach ($contents as $k) {
      $db->put("$key/$k", '');
    }

    return false;
  }

  // Check for an id at the bank. Return false if not there.
  // Return array($t->PUBKEY => $pubkey,
  //              $t->NAME => $name)
  function get_id($id) {
    $t = $this->t;
    $db = $this->db;
    $bankid = $this->bankid;
    $ssl = $this->ssl;

    if (!$bankid) return false;

    $key = $this->userbankkey($t->PUBKEYSIG) . "/$id";
    $msg = $db->get($key);
    $needstore = false;
    if (!$msg) {
      $msg = $this->sendmsg($t->ID, $bankid, $id);
      $needstore = true;
    }    
    $args = $this->unpack_bankmsg($msg, $t->ATREGISTER);
    if (is_string($args)) return false;
    $args = $args[$t->MSG];
    $pubkey = $args[$t->PUBKEY];
    if ($id != $ssl->pubkey_id($pubkey)) return false;

    if ($needstore) $db->put($key, $msg);

    $res = array();
    $res[$t->ID] = $args[$t->CUSTOMER];
    $res[$t->PUBKEY] = $args[$t->PUBKEY];
    $res[$t->NAME] = $args[$t->NAME];
    $res[$t->MSG] = $msg;

    return $res;
  }

  // GET sub-account names.
  // Returns an error string or an array of the sub-account names
  function getaccts() {
    $db = $this->db;

    if (!$this->current_bank()) return "In getaccts(): Bank not set";
    if ($err = $this->initbankaccts()) return $err;
    
    $res = $db->contents($this->userbalancekey());
    usort($res, array('client', 'compareaccts'));
    return $res;
  }

  // For usort in getassets
  function compareassets($c1, $c2) {
    $t = $this->t;

    return $this->comparearrays($c1, $c2, array($t->ASSETNAME, $t->ASSET));
  }

  // Return the assets for which the customer has balances
  // array($assetid => <getasset() result>, ...)
  function getassets() {
    $db = $this->db;
    $t = $this->t;

    $res = array();
    $bankid = $this->bankid;

    if ($bankid) {
      $key = $this->userbalancekey();
      $accts = $db->contents($key);
      foreach ($accts as $acct) {
        $assetids = $db->contents("$key/$acct");
        foreach ($assetids as $assetid) {
          if (!$res[$assetid]) {
            $asset = $this->getasset($assetid);
            if ($asset) $res[$assetid] = $asset;
          }
        }
      }
    }

    uasort($res, array("client", "compareassets"));
    return $res;
  }

  // Look up an asset.
  // Returns an error string or an array of items of the form:
  //
  //   array($t->ID => $issuerid,
  //         $t->ASSET => $assetid,
  //         $t->SCALE => $scale,
  //         $t->PRECISION => $precision,
  //         $t->ASSETNAME => $assetname)
  //
  // If the asset isn't found in the client database, looks it up on the
  // server, and stores it in the client database.
  function getasset($assetid) {
    $t = $this->t;
    $db = $this->db;

    if (!$this->current_bank()) return "In getacct(): Bank not set";

    $key = $this->assetkey($assetid);
    $lock = $db->lock($key, true);
    $msg = $db->get($key);
    if ($msg) {
      $db->unlock($lock);
      $args = $this->unpack_bankmsg($msg, $t->ATASSET);
      if (is_string($args)) return "While matching asset: $args";
      $args = $args[$t->MSG];
    } else {
      $args = $this->getasset_internal($assetid, $key);
      $db->unlock($lock);
      if (is_string($args)) return $args;
    }

    return array($t->ID => $args[$t->CUSTOMER],
                 $t->ASSET => $assetid,
                 $t->SCALE => $args[$t->SCALE],
                 $t->PRECISION => $args[$t->PRECISION],
                 $t->ASSETNAME => $args[$t->ASSETNAME]);
  }

  function getasset_internal($assetid, $key) {
    $t = $this->t;
    $db = $this->db;

    $bankid = $this->bankid;
    $req = $this->getreq();
    if (!$req) return "Couldn't get req for getasset";
    $msg = $this->sendmsg($t->GETASSET, $bankid, $req, $assetid);
    $args = $this->unpack_bankmsg($msg, $t->ATASSET);
    if (is_string($args)) return "While downloading asset: $args";
    $args = $args[$t->MSG];
    if ($args[$t->REQUEST] != $t->ASSET ||
        $args[$t->BANKID] != $bankid ||
        $args[$t->ASSET] != $assetid) {
      return "Bank wrapped wrong object with @asset";
    }
    $db->put($key, $msg);
    return $args;
  }

  function addasset($scale, $precision, $assetname) {
    $t = $this->t;
    $db = $this->db;

    $lock = $db->lock($this->userreqkey());
    $res = $this->addasset_internal($scale, $precision, $assetname);
    $db->unlock($lock);

    if ($res) $this->forceinit();

    return $res;
  }

  function addasset_internal($scale, $precision, $assetname) {
    $t = $this->t;
    $u = $this->u;
    $db = $this->db;
    $id = $this->id;
    $bankid = $this->bankid;
    $server = $this->server;
    $parser = $this->parser;

    if (!$id || !$bankid) return "Can't add asset unless bank is set";

    $assetid = $u->assetid($id, $scale, $precision, $assetname);
    $time = $this->gettime();
    if (!$time) return "While adding asset: can't get timestamp";
    $fees = $this->getfees();
    if (is_string($fees)) return "While adding asset: $fees";
    $tranfee = $fees[$t->TRANFEE];
    $tokenid = $tranfee[$t->ASSET];
    
    $process = $this->custmsg($t->ASSET, $bankid, $assetid, $scale, $precision, $assetname);
    $bal1 = $this->getbalance($t->MAIN, $tokenid);
    if (is_string($bal1)) return $bal1;
    $bal1 = $bal1[$t->AMOUNT];
    if ($id == $bankid) $bal1 = '';
    else {
      $ispos = (bccomp($bal1, 0) >= 0);
      $bal1 = bcsub($bal1, 2);
      if ($ispos && (bccomp($bal1, 0) < 0)) {
        return "You need 2 usage tokens to create a new asset";
      }
      $bal1 = $this->custmsg($t->BALANCE, $bankid, $time, $tokenid, $bal1);
    }
    $bal2 = $this->custmsg($t->BALANCE, $bankid, $time, $assetid, -1);

    $acctbals = array($t->MAIN => array($assetid => $bal2));
    if ($bal1) $acctbals[$t->MAIN][$tokenid] = $bal1;
    $balancehash = $this->balancehashmsg($time, $acctbals);

    $msg = $process;
    if ($bal1) $msg .= ".$bal1";
    $msg .= ".$bal2.$balancehash";
    $msg = $server->process($msg);

    // Request sent. Check for error
    $reqs = $this->parser->parse($msg);
    if (!$reqs) return "While adding asset: " . $parser->errmsg;
    $gotbal1 = $gotbal2 = false;
    foreach ($reqs as $req) {
      $args = $this->match_bankreq($req);
      if (is_string($args)) return "While adding asset: $args";
      if ($args[$t->REQUEST] == $t->FAILED) {
        return "While adding asset: " . $args[$t->ERRMSG];
      }
      $msg = $parser->get_parsemsg($req);
      $m = $args[$t->MSG];
      $m = trim($parser->get_parsemsg($m));
      if ($m == $bal1) $gotbal1 = $msg;
      elseif ($m == $bal2) $gotbal2 = $msg;
    }

    if (!(($gotbal1 || (!$bal1)) && $gotbal2)) {
      return "While adding asset: missing returned balance from server";
    }

    // All is well. Commit the balance changes
    if ($bal1) $db->put($this->userbalancekey($t->MAIN, $tokenid), $gotbal1);
    $db->put($this->userbalancekey($t->MAIN, $assetid), $gotbal2);

    $this->getasset($assetid);

    return false;
  }

  // Look up the transaction cost.
  // Returns an error string or an array of the form:
  //
  //   array($t->TRANFEE => ARRAY(ARRAY($t->ASSET => $assetid,
  //                                    $t->AMOUNT => $amount),
  //                              ...),
  //         $t->REGFEE => ARRAY(ARRAY($t->ASSET => $assetid,
  //                                   $t->AMOUNT => $assetid),
  //                             ...),
  //         $t->FEE|<operation> => ARRAY(ARRAY($t->ASSET => $assetid,
  //                                            $t->AMOUNT => $assetid),
  //                                      ...),
  //         ...)
  //
  // Currently, only the tranfee and regfee are supported by the server,
  // and only a single fee, in usage tokens, is charged for each.
  // So that's all the spend code handles.
  //
  // If the asset isn't found in the client database, looks it up on the
  // server, and stores it in the client database.
  function getfees($reload=false) {
    $t = $this->t;
    $db = $this->db;

    if (!$this->current_bank()) return "In getfees(): Bank not set";

    $key = $this->tranfeekey();
    $lock = $db->lock($key, true);
    $msg = $db->get($key);
    if ($msg) {
      $db->unlock($lock);
      $args = $this->unpack_bankmsg($msg, $t->TRANFEE);
      if (is_string($args)) return "While matching tranfee: $args";
    } else {
      $args = $this->getfees_internal($key);
      $db->unlock($lock);
      if (is_string($args)) return $args;
    }

    $tranfee = array($t->ASSET => $args[$t->ASSET],
                     $t->AMOUNT => $args[$t->AMOUNT]);

    $msg = $this->regfee();
    if (!$msg) return "Regfee not initialized";
    $args = $this->unpack_bankmsg($msg, $t->REGFEE);
    if (is_string($args)) return "While matching regfee: $args";

    $regfee = array($t->ASSET => $args[$t->ASSET],
                    $t->AMOUNT => $args[$t->AMOUNT]);

    return array($t->TRANFEE => $tranfee,
                 $t->REGFEE => $regfee);
  }

  function getfees_internal($key) {
    $t = $this->t;
    $db = $this->db;
    $parser = $this->parser;
    $bankid = $this->bankid;

    $req = $this->getreq();
    if (!$req) return "Couldn't get req for getfees";
    $msg = $this->sendmsg($t->GETFEES, $bankid, $req);
    $reqs = $parser->parse($msg);
    if (!$reqs) return "While parsing getfees return message: " . $parser->errmsg;
    $feeargs = false;
    foreach ($reqs as $req) {
      $args = $this->match_bankreq($req);
      if (is_string($args)) return "While matching getfees return: $args";
      if ($args[$t->REQUEST] == $t->TRANFEE) {
        $db->put($key, $parser->get_parsemsg($req));
        $feeargs = $args;
      } elseif ($args[$t->REQUEST] == $t->REGFEE) {
        $db->put($this->regfeekey(), $parser->get_parsemsg($req));
      }
    }

    if (!$feeargs) $feeargs = "No tranfee from getfees request";
    return $feeargs;
  }

  // Get user balances for all sub-accounts or just one.
  // Returns an error string or an array of items of the form:
  //
  //    array($acct => array($t->ASSET =>
  //                         array($t->ASSET => $assetid,
  //                               $t->ASSETNAME => $assetname,
  //                               $t->AMOUNT => $amount,
  //                               $t->FORMATTEDAMOUNT => $formattedamount),
  //                         ...),
  //          ...)
  //
  // where $assetid & $assetname describe the asset, $amount is the
  // amount, as an integer, $formattedamount is the amount as a
  // decimal number with the scale and precision applied, and $acct
  // is the name of the sub-account(s).
  //
  // The $acct arg is true for all sub-accounts, false for the
  // $t->MAIN sub-account only, or a string for that sub-account only.
  // The $assetid arg is false for all asset or an ID for that asset only.
  //
  // If you a specific $acct and a specific $assetid, the result
  // is an array mapping property names to values, not an array of arrays.
  function getbalance($acct=true, $assetid=false) {
    $t = $this->t;
    $db = $this->db;

    if (!$this->current_bank()) return "In getbalance(): Bank not set";
    if ($err = $this->initbankaccts()) return $err;

    $lock = $db->lock($this->userreqkey());
    $res = $this->getbalance_internal($acct, $assetid);
    $db->unlock($lock);

    return $res;
  }

  function compareaccts($a1, $a2) {
    $t = $this->t;

    if ($a1 == $t->MAIN) {
      if ($a2 == $t->MAIN) return 0;
      return -1;
    } elseif ($a2 == $t->MAIN) return 1;
    return strcmp(strtolower($a1), strtolower($a2));
  }

  function comparebalances($b1, $b2) {
    $t = $this->t;

    return $this->comparearrays($b1, $b2, array($t->ASSETNAME, $t->ASSET));
  }

  function getbalance_internal($inacct, $inassetid) {
    $t = $this->t;
    $db = $this->db;

    if (!$inacct) $inacct = $t->MAIN;
    if (is_string($inacct)) $accts = array($inacct);
    else {
      $accts = $db->contents($this->userbalancekey());
      usort($accts, array('client', 'compareaccts'));
    }

    $res = array();
    foreach ($accts as $acct) {
      if ($inassetid) $assetids = array($inassetid);
      else $assetids = $db->contents($this->userbalancekey($acct));
      $assets = array();
      foreach ($assetids as $assetid) {
        $amount = $this->userbalance($acct, $assetid);
        if (!is_numeric($amount)) return "While gathering balances: $amount";
        $asset = $this->getasset($assetid);
        if (is_string($asset)) {
          $formattedamount = $amount;
          $assetname = "Unknown asset";
        } else {
          $formattedamount = $this->format_asset_value($amount, $asset);
          $assetname = $asset[$t->ASSETNAME];
        }
        $assets[$assetid] = array($t->ASSET => $assetid,
                                  $t->ASSETNAME => $assetname,
                                  $t->AMOUNT => $amount,
                                  $t->FORMATTEDAMOUNT => $formattedamount);
      }
      uasort($assets, array('client', 'comparebalances'));
      $res[$acct] = $assets;
    }
    if (is_string($inacct) && $inassetid) {
      if (count($res) == 0) $res = false;
      else $res = $res[$inacct][$inassetid];
    }
    return $res;
  }

  // Initiate a spend
  // $toid is the id of the recipient of the spend
  //   May be $t->COUPON to generate a coupon
  //   In that case, the coupon itself can be fetched with getcoupon()
  // $assetid is the id of the asset to spend
  // $formattedamount is the formatted amount to spend
  // $acct is the source sub-account, default $t->MAIN
  // $acct can also be array($fromacct, $toacct), for a transfer.
  // In that case $toid should be the logged in ID.
  // Fees are always taken from $t->MAIN
  function spend($toid, $assetid, $formattedamount, $acct=false, $note=false) {
    $t = $this->t;
    $db = $this->db;

    if (!$this->current_bank()) return "In spend(): Bank not set";
    if ($err = $this->initbankaccts()) return $err;

    $lock = $db->lock($this->userreqkey());
    $res = $this->spend_internal($toid, $assetid, $formattedamount, $acct, $note);
    $db->unlock($lock);

    if ($res) $this->forceinit();

    return $res;
  }

  function spend_internal($toid, $assetid, $formattedamount, $acct, $note) {
    $t = $this->t;
    $db = $this->db;
    $u = $this->u;

    $id = $this->id;
    $bankid = $this->bankid;
    $server = $this->server;
    $parser = $this->parser;

    if (!$acct) $acct = $t->MAIN;
    $toacct = $t->MAIN;
    if (!is_string($acct)) {
      $toacct = $acct[1];
      $acct = $acct[0];
      if (!(is_string($acct) && is_string($toacct))) {
        return "Bad accts: from: $acct, to: $to_acct";
      }
    }

    if ($id == $toid && $acct == $toacct) {
      return "Transfer from and  to the same ($acct). Nothing to do.";
    }

    $amount = $this->unformat_asset_value($formattedamount, $assetid);
    if (bccomp($amount, 0) <= 0) return "You may only spend a positive amount";

    $oldamount = $this->userbalance($acct, $assetid);
    if (!is_numeric($oldamount)) {
      return "Error getting balance for asset in acct $acct: $oldamount";
    }

    $newamount = bcsub($oldamount, $amount);
    if (bccomp($oldamount, 0) >= 0 &&
        bccomp($newamount,  0) < 0) {
      return "Insufficient balance, old: $oldamount, new: $newamount";
    }

    if ($id == $toid) {
      $oldtoamount = $this->userbalance($toacct, $assetid);
      $newtoamount = bcadd($oldtoamount, $amount);
      if (bccomp($oldtoamount, 0) < 0 &&
          bccomp($newtoamount, 0) >=0) {
        // This shouldn't be possible.
        // If it happens, it means the asset is out of balance.
        return "Asset out of balance, old: $oldtoamount, new: $newtoamount";
      }
    }

    $tranfee = false;
    $need_fee_balance = false;
    if ($id != $bankid) {
      $fees = $this->getfees();
      if (is_string($fees)) return $fees;
      $tranfee = $fees[$t->TRANFEE];
      $tranfee_asset = $tranfee[$t->ASSET];
      if ($id != $toid) $tranfee_amt = $tranfee[$t->AMOUNT];
      else $tranfee_amt = ($oldtoamount === false) ? 1 : 0;
      if ($tranfee_asset == $assetid && $t->MAIN == $acct) {
        $newamount = bcsub($newamount, $tranfee_amt);
        if (bccomp($oldamount, 0) >= 0 &&
            bccomp($newamount, 0) < 0) {
          return "Insufficient balance for transaction fee";
        }
      } elseif ($id == $toid && $tranfee_asset == $assetid && $t->MAIN = $toacct) {
        $newtoamount = bcsub($newtoamount, $tranfee_amt);
        if ($newtoamount == $oldtoamount) {
          "Transferring one token to a new acct is silly";
        }
        if (bccomp($oldtoamount, 0) >= 0 &&
            bccomp($newtoamount, 0) < 0) {
          return "Insufficient destination balance for transaction fee";
        }
      } else {
        $old_fee_balance = $this->userbalance($t->MAIN, $tranfee_asset);
        $fee_balance = bcsub($old_fee_balance, $tranfee_amt);
        $need_fee_balance = true; // $fee_balance could be 0
        if (bccomp($old_fee_balance, 0) >= 0 &&
            bccomp($fee_balance, 0) < 0) {
          return "Insufficient tokens for transaction fee";
        }
      }
    }

    $this->debugmsg("fee_balance: '$fee_balance', need_fee_balance: '$need_fee_balance'\n");

    $time = $this->gettime();
    if (!$time) return "Unable to get timestamp for transaction from bank";
    if ($note) $spend = $this->custmsg($t->SPEND, $bankid, $time, $toid,
                                       $assetid, $amount, $note);
    else $spend = $this->custmsg($t->SPEND, $bankid, $time, $toid, $assetid, $amount);
    $feeandbal = '';
    if ($tranfee_amt) {
      if ($id != $toid) {
        $feemsg = $this->custmsg
          ($t->TRANFEE, $bankid, $time, $tranfee_asset, $tranfee_amt);
        $feeandbal = $feemsg;
      }
      $feebal = false;
      if ($need_fee_balance) {
        $feebal = $this->custmsg
          ($t->BALANCE, $bankid, $time, $tranfee_asset, $fee_balance);
        if ($feeandbal) $feeandbal .= '.';
        $feeandbal .= $feebal;
      }
    }      
    $balance = $this->custmsg
      ($t->BALANCE, $bankid, $time, $assetid, $newamount, $acct);
    $tobalance = false;
    if ($id == $toid) {
      $tobalance = $this->custmsg($t->BALANCE, $bankid, $time,
                                  $assetid, $newtoamount, $toacct);
    }
    $outboxhash = '';
    if ($id != $bankid && $id != $toid) {
      $outboxhash = $this->outboxhashmsg($time, $spend);
    }

    // Compute balancehash
    if ($id != $bankid) {
      if ($feebal) {
        if ($t->MAIN == $acct) {
          $acctbals = array($acct => array($assetid => $balance,
                                           $tranfee_asset => $feebal));
          if ($tobalance) $acctbals[$toacct] = array($assetid => $tobalance);
        } elseif ($id == $toid && $t->MAIN == $toacct) {
          $acctbals = array($acct => array($assetid => $balance),
                            $t->MAIN => array($assetid => $tobalance,
                                              $tranfee_asset => $feebal));
        } else {
          $acctbals = array($acct => array($assetid => $balance),
                            $t->MAIN => array($tranfee_asset => $feebal));
          if ($tobalance) $acctbals[$toacct] = array($assetid => $tobalance);
        }
      } else {
        $acctbals = array($acct => array($assetid => $balance));
        if ($tobalance) $acctbals[$toacct] = array($assetid => $tobalance);
      }
      $balancehash = $this->balancehashmsg($time, $acctbals);
    }

    // Send request to server, and get response
    $msg = $spend;
    if ($feeandbal) $msg.= ".$feeandbal";
    $msg .= ".$balance";
    if ($tobalance) $msg .= ".$tobalance";
    if ($outboxhash) $msg .= ".$outboxhash";
    if ($balancehash) $msg .= ".$balancehash";
    $msg = $server->process($msg);

    $reqs = $parser->parse($msg);
    if (!$reqs) return "Can't parse bank return from spend: $msg";
    $spendargs = $this->match_bankreq($reqs[0], $t->ATSPEND);
    if (is_string($spendargs)) {
      $args = $this->match_bankreq($reqs[0]);
      if (is_string($args)) return $args;
      $request = $args[$t->REQUEST];
      if ($request = $t->FAILED) return "Spend request failed: " . $args[$t->ERRMSG];
      return "Spend request returned unknown message type: " . $request;
    }

    $msgs = array($spend => true,
                  $balance => true);
    if ($tobalance) $msgs[$tobalance] = true;
    if ($outboxhash) $msgs[$outboxhash] = true;
    if ($balancehash) $msgs[$balancehash] = true;
    if ($feeandbal) {
      if ($feemsg) $msgs[$feemsg] = true;
      if ($feebal) $msgs[$feebal] = true;
    }

    $coupon = false;
    foreach ($reqs as $req) {
      $msg = $parser->get_parsemsg($req);
      $args = $this->match_bankreq($req);
      if (is_string($args)) return "Error in spend response: $args";
      if ($args[$t->REQUEST] == $t->COUPONENVELOPE) {
        if ($coupon) return "Multiple coupons returned from server";
        $coupon = $msg;
        $encryptedcoupon = $args[$t->ENCRYPTEDCOUPON];
      } else {
        $m = $args[$t->MSG];
        if (!$m) return "No wrapped message in spend return: $msg";
        $m = trim($parser->get_parsemsg($m));
        if (!$msgs[$m]) return "Returned message wasn't sent: '$m'";
        if (is_string($msgs[$m])) return "Duplicate returned message: '$m'";
        $msgs[$m] = $msg;
      }
    }

    foreach ($msgs as $m => $msg) {
      if ($msg === true) return "Message not returned from spend: $m";
    }

    // All is well. Commit this baby.
    $db->put($this->userbalancekey($acct, $assetid), $msgs[$balance]);
    if ($tobalance) {
      $db->put($this->userbalancekey($toacct, $assetid), $msgs[$tobalance]);
    }
    if ($outboxhash) {
      $db->put($this->useroutboxhashkey(), $msgs[$outboxhash]);
    }
    if ($balancehash) {
      $db->put($this->userbalancehashkey(), $msgs[$balancehash]);
    }
    $spend = $msgs[$spend];
    if ($feeandbal) {
      $spend = "$spend." . $msgs[$feemsg];
      if ($feebal) {
        $db->put($this->userbalancekey($t->MAIN, $tranfee_asset), $msgs[$feebal]);
      }
    }
    if ($coupon) {
      $spend .= ".$coupon";
      $this->coupon = $encryptedcoupon;
    }
    if ($id != $toid) $db->put($this->useroutboxkey($time), $spend);
    $this->lastspendtime = $time;

    return false;    
  }

  // Return the last coupon resulting from a spend.
  // Clear the coupon store, so you can only get the coupon once.
  function getcoupon() {
    $ssl = $this->ssl;
    $privkey = $this->privkey;

    $coupon = $this->coupon;
    $this->coupon = false;
    return $ssl->privkey_decrypt($coupon, $privkey);
  }

  // Transfer from one sub-account to another
  function transfer($assetid, $formattedamount, $fromacct, $toacct) {

    if (!$this->current_bank()) return "In transfer(): Bank not set";
    if ($err = $this->initbankaccts()) return $err;

  }

  // Get the inbox contents.
  // Returns an error string, or an array of inbox entries, indexed by
  // their timestamps:
  //
  //   array($time => array(array($t->REQUEST => $request
  //                              $t->ID => $fromid,
  //                              $t->TIME => $time,
  //                              $t->MSGTIME => $msgtime,
  //                              $t->ASSET => $assetid,
  //                              $t->ASSETNAME => $assetname,
  //                              $t->AMOUNT => $amount,
  //                              $t->FORMATTEDAMOUNT => $formattedamount,
  //                              $t->NOTE => $note),j
  //                        ...)
  //          ...)
  //
  // Where $request is $t->SPEND, $t->SPENDACCEPT, or $t->SPENDREJECT,
  // $fromid is the ID of the sender of the inbox entry,
  // $time is the timestamp from the bank on the inbox entry,
  // $msgtime is the timestamp in the sender's message,
  // $assetid & $assetname describe the asset being transferred,
  // $amount is the amount of the asset being transferred, as an integer,
  // $formattedamount is the amount as a decimal number with the scale
  // and precision applied,
  // and $NOTE is the note that came from the sender.
  // There will usually be two entries for a SPEND inbox entry, the SPEND
  // and the corresponding TRANFEE.
  // SPENDACCEPT and SPENDREJECT entries will be by themselves.
  function getinbox() {
    $db = $this->db;

    if (!$this->current_bank()) return "In getinbox(): Bank not set";
    if ($err = $this->initbankaccts()) return $err;

    $lock = $db->lock($this->userreqkey());
    $res = $this->getinbox_internal();
    $db->unlock($lock);

    if ($res) $this->forceinit();

    return $res;
  }

  function getinbox_internal() {
    $t = $this->t;
    $db = $this->db;
    $parser = $this->parser;

    $err = $this->sync_inbox();
    if ($err) return $err;

    $res = array();
    $key = $this->userinboxkey();
    $inbox = $db->contents($key);
    foreach ($inbox as $time) {
      $msg = $db->get("$key/$time");
      $reqs = $parser->parse($msg);
      if (!$reqs) return "Inbox parsing error: $reqs";
      $items = array();
      foreach ($reqs as $req) {
        $args = $this->match_bankreq($req);
        if (is_string($args)) return "Inbox unpack error: $args";
        if ($args[$t->TIME] != $time && $args[$t->TIME]) {
          return "Inbox message timestamp mismatch";
        }
        $args = $args[$t->MSG];
        $request = $args[$t->REQUEST];
        $item = array();
        $item[$t->REQUEST] = $request;
        $item[$t->ID] = $args[$t->CUSTOMER];
        $item[$t->TIME] = $time;
        $item[$t->MSGTIME] = $args[$t->TIME];
        $item[$t->NOTE] = $args[$t->NOTE];
        if ($request == $t->SPEND || $request = $t->TRANFEE) {
          $assetid = $args[$t->ASSET];
          $amount = $args[$t->AMOUNT];
          $asset = $this->getasset($assetid);
          $item[$t->ASSET] = $assetid;
          $item[$t->AMOUNT] = $amount;
          if (!is_string($asset)) {
            $item[$t->ASSETNAME] = $asset[$t->ASSETNAME];
            $item[$t->FORMATTEDAMOUNT] =
              $this->format_asset_value($amount, $asset, false);
          }
        } elseif ($request == $t->SPENDACCEPT || $request == $t->SPENDREJECT) {
          // Pull in data from outbox to get amounts
        } else {
          return "Bad request in inbox: $request";
        }
        $items[] = $item;
      }
      $res[$time] = $items;
    }

    return $res;
  }

  // Synchronize the current customer inbox with the current bank.
  // Return a string on error or false on success.
  // Assumes that there IS a current user and bank.
  // Does no database locking.
  function sync_inbox() {
    $t = $this->t;
    $db = $this->db;

    $bankid = $this->bankid;
    $parser = $this->parser;
    $server = $this->server;

    $req = $this->getreq();
    if (!$req) return "Couldn't get req for getinbox";
    $msg = $this->custmsg($t->GETINBOX, $bankid, $req);
    $bankmsg = $server->process($msg);
    
    $reqs = $parser->parse($bankmsg);
    if (!$reqs) return "While parsing getinbox return message: " . $parser->errmsg;
    $inbox = array();
    $times = array();
    $last_time = false;
    foreach ($reqs as $req) {
      $args = $this->match_bankreq($req);
      if (is_string($args)) return "While matching getinbox return: $args";
      $bankmsg = $parser->get_parsemsg($req);
      $request = $args[$t->REQUEST];
      if ($request == $t->ATGETINBOX) {
        $retmsg = $parser->get_parsemsg($args[$t->MSG]);
        if (trim($retmsg) != trim($msg)) return "getinbox return doesn't wrap message sent";
        $last_time = false;
      } elseif ($request == $t->INBOX) {
        $time = $args[$t->TIME];
        if ($inbox[$time]) return "getinbox return included multiple entried for time: $time";
        $inbox[$time] = $bankmsg;
        $last_time = $time;
      } elseif ($request == $t->ATTRANFEE) {
        if (!$last_time) return "In getinbox return: @tranfee not after inbox";
        $inbox[$last_time] .= ".$bankmsg";
      } elseif ($request == $t->TIME) {
        $times[] = $args[$t->TIME];
      } elseif ($request != $t->COUPONNUMBERHASH) {
        return "Unknown request in getinbox return: $request";
      }
    }

    $key = $this->userinboxkey();
    $keys = $db->contents($key);
    foreach ($keys as $time) {
      $inmsg = $inbox[$time];
      if ($inmsg) {
        $msg = $db->get("$key/$time");
        if ($msg != $inmsg) return "Inbox mismatch at time: $time";
        unset($inbox[$time]);
      } else {
        $db->put("$key/$time", '');
      }
    }
    foreach ($inbox as $time => $msg) {
      $db->put("$key/$time", $msg);
    }
    if (count($times) > 0) {
      $db->put($this->usertimekey(), implode(',', $times));
    }
  }

  // Process the inbox contents.
  // $directions is an array of items of the form:
  //
  //  array($t->TIME => $time,
  //        $t->REQUEST => $request,
  //        $t->NOTE => $note,
  //        $t->ACCOUNT => $acct)
  //
  // where $time is a timestamp in the inbox,
  // $request is $t->SPENDACCEPT or $t->SPENDREJECT, or omitted for
  // processing an accept or reject from a former spend recipient,
  // $note is the note to go with the accept or reject, and
  // $acct is the account into which to transfer the funds (default: main).

  function processinbox($directions) {
    $db = $this->db;

    if (!$this->current_bank()) return "In processinbox(): Bank not set";
    if ($err = $this->initbankaccts()) return $err;

    $lock = $db->lock($this->userreqkey());
    $res = $this->processinbox_internal($directions, false);
    $db->unlock($lock);

    if ($res) $this->forceinit();

    return $res;
  }

  function processinbox_internal($directions, $recursive) {
    $t = $this->t;
    $db = $this->db;

    $bankid = $this->bankid;
    $server = $this->server;
    $parser = $this->parser;

    $inbox = $this->getinbox_internal();
    $outbox = $this->getoutbox_internal();
    $balance = $this->getbalance_internal(true, false);

    $timelist = '';
    $deltas = array(); // array($acct => array($asset => $delta, ...), ...)
    $outbox_deletions = array(); // array($timestamp, ...)

    $msg = '';
    $msgs = array();

    foreach ($directions as $dir) {
      $time = $dir[$t->TIME];
      $request = $dir[$t->REQUEST];
      $note = $dir[$t->NOTE];
      $acct = $dir[$t->ACCT];
      if (!$acct) $acct = $t->MAIN;

      if ($timelist) $timelist .= '|';
      $timelist .= $time;

      $ins = $inbox[$time];
      if (!$ins) return "No inbox entry for time: $time";

      $in = $ins[0];
      $fee = $ins[1];        // will need generalization when I add multiple fees

      $trans = $this->gettime();

      $inreq = $in[$t->REQUEST];
      if ($inreq == $t->SPEND) {
        $id = $in[$t->ID];
        $msgtime = $in[$t->MSGTIME];
        if ($msg != '') $msg .= '.';
        if ($request == $t->SPENDACCEPT) {
          $deltas[$acct][$in[$t->ASSET]] =
            bcadd($deltas[$acct][$in[$t->ASSET]], $in[$t->AMOUNT]);
          $smsg = $this->custmsg($t->SPENDACCEPT, $bankid, $msgtime, $id, $note);
          $msgs[$smsg] = true;
          $msg .= $smsg;
        } elseif ($request == $t->SPENDREJECT) {
          if ($fee) {
            $deltas[$acct][$fee[$t->ASSET]] =
              bcadd($deltas[$acct][$fee[$t->ASSET]], $fee[$t->AMOUNT]);
          }
          $smsg = $this->custmsg($t->SPENDREJECT, $bankid, $msgtime, $id, $note);
          $msgs[$smsg] = true;
          $msg .= $smsg;
        } else {
          return "Illegal request for spend: $request";
        }
      } elseif ($inreq == $t->SPENDACCEPT || $inreq == $t->SPENDREJECT) {
        $msgtime = $in[$t->MSGTIME];
        $out = $outbox[$msgtime];
        if (!$out) return "Can't find outbox for $inreq at time $msgtime";
        $outbox_deletions[] = $msgtime;
        $outspend = $out[0];
        $outfee = $out[1];      // change when we have more than one fee
        if ($inreq == $t->SPENDREJECT) {
          // For rejected spends, we get our money back
          $deltas[$acct][$outspend[$t->ASSET]] =
            bcadd($deltas[$acct][$outspend[$t->ASSET]], $outspend[$t->AMOUNT]);
        } elseif ($outfee) {
          // For accepted spends, we get our tranfee back
          $deltas[$t->MAIN][$outfee[$t->ASSET]] =
            bcadd($deltas[$t->MAIN][$outfee[$t->ASSET]], $outfee[$t->AMOUNT]);
        }
      } else {
        return "Unrecognized inbox request: $inreq";
      }
    }

    $pmsg = $this->custmsg($t->PROCESSINBOX, $bankid, $trans, $timelist);
    $msgs[$pmsg] = true;

    if ($msg) $msg = "$pmsg.$msg";
    else $msg = $pmsg;

    $acctbals = array();

    // Compute fees for new balance files
    $fees = $this->getfees();
    if (is_string($fees)) return $fees;
    $tranfee = $fees[$t->TRANFEE];
    $feeasset = $tranfee[$t->ASSET];
    foreach ($deltas as $acct => $amounts) {
      foreach ($amounts as $asset => $amount) {
        $oldamount = $balance[$acct][$asset][$t->AMOUNT];
        if ((!$oldamount) && !($oldamount===0)) {
          $deltas[$t->MAIN][$feeasset] = bcsub($deltas[$t->MAIN][$feeasset], 1);
        }
      }
    }

    // Create balance, outboxhash, and balancehash messages
    foreach ($deltas as $acct => $amounts) {
      foreach ($amounts as $asset => $amount) {
        $oldamount = $balance[$acct][$asset][$t->AMOUNT];
        $amount = bcadd($oldamount, $amount);
        $balmsg = $this->custmsg($t->BALANCE, $bankid, $trans, $asset, $amount, $acct);
        $msgs[$balmsg] = true;
        $acctbals[$acct][$asset] = $balmsg;
        $msg = $msg . ".$balmsg";
      }
    }

    if (count($outbox_deletions) > 0) {
      $outboxhash = $this->outboxhashmsg($trans, false, $outbox_deletions);
      $msgs[$outboxhash] = true;
      $msg = $msg . ".$outboxhash";
    } else $outboxhash = false;

    $balancehash = $this->balancehashmsg($trans, $acctbals);
    $msgs[$balancehash] = true;
    $msg = $msg . ".$balancehash";

    // Send request to server
    $msg = $server->process($msg);

    // Validate return from server
    $reqs = $parser->parse($msg);
    if (!$reqs) return "Can't parse bank return from spend: $msg";
    $args = $this->match_bankreq($reqs[0], $t->ATPROCESSINBOX);
    if (is_string($args)) {
      $args = $this->match_bankreq($reqs[0]);
      if (is_string($args)) {
        if (!$recursive) {
          // Force reload of balances and outbox
          if ($err = $this->forceinit()) return $err;
          return $this->processinbox_internal($directions, true);
        }
        return "Error from processinbox request: $args";
      }
      return "Processinbox request returned unknown message type: " . $request;
    }

    foreach ($reqs as $req) {
      $msg = $parser->get_parsemsg($req);
      $args = $this->match_bankreq($req);
      if (is_string($args)) return "Error in processinbox response: $args";
      $m = $args[$t->MSG];
      if (!$m) return "No wrapped message in processinbox return: $msg";
      $m = trim($parser->get_parsemsg($m));
      if (!$msgs[$m]) return "Returned message wasn't sent: '$m'";
      if (is_string($msgs[$m])) return "Duplicate returned message: '$m'";
      $msgs[$m] = $msg;
    }

    foreach ($msgs as $m => $msg) {
      if ($msg === true) return "Message not returned from processinbox: $m";
    }

    // Commit to database
    foreach ($acctbals as $acct => $bals) {
      foreach ($bals as $asset => $balmsg) {
        $db->put($this->userbalancekey($acct, $asset), $msgs[$balmsg]);
      }
    }

    if ($outboxhash) {
      foreach($outbox_deletions as $outbox_time) {
        $db->put($this->useroutboxkey($outbox_time), '');
      }
      $db->put($this->useroutboxhashkey(), $msgs[$outboxhash]);
    }

    $db->put($this->userbalancehashkey(), $msgs[$balancehash]);

    return false;
  }

  // Get the outbox contents.
  // Returns an error string or the outbox contents as an array of
  // of the form:
  //
  //   array($time => array(array($t->REQUEST => $request,
  //                              $t->TIME => $time,
  //                              $t->ID => $recipientid,
  //                              $t->NOTE => $note,
  //                              $t->ASSET => $assetid,
  //                              $t->ASSETNAME => $assetname,
  //                              $t->AMOUNT => $amount,
  //                              $t->FORMATTEDAMOUNT => formattedamount),
  //                        ...),
  //         ...)
  //
  // $time is the timestamp of the outbox entry
  // $request is $t->SPEND, $t->TRANFEE, or $t->COUPONENVELOPE
  // $recipientid is the recipient for spend, or omitted for tranfee
  // $assetid is the ID of the asset transferred
  // $assetname is the name of $assetid
  // $amount is the amount transferred
  // $formattedamount is $amount formatted for output
  // $note is the transfer note, omitted for tranfee
  //
  // If $request is $t->COUPONENVELOPE, then $t->COUPON indexes the coupon itself,
  // as text, and the rest of the fields are unpopulated.
  function getoutbox() {
    $db = $this->db;

    if (!$this->current_bank()) return "In getoutbox(): Bank not set";
    if ($err = $this->initbankaccts()) return $err;

    $lock = $db->lock($this->userreqkey());
    $res = $this->getoutbox_internal();
    $db->unlock($lock);

    return $res;
  }

  function getoutbox_internal() {
    $t = $this->t;
    $db = $this->db;
    $parser = $this->parser;

    $res = array();
    $key = $this->useroutboxkey();
    $outbox = $db->contents($key);
    foreach ($outbox as $time) {
      $msg = $db->get("$key/$time");
      $reqs = $parser->parse($msg);
      $items = array();
      if (!$reqs) return "Parse error: " . $parser->errmsg;
      foreach ($reqs as $req) {
        $args = $this->match_bankreq($req);
        if (is_string($args)) return $args;
        $request = $args[$t->REQUEST];
        if ($request != $t->COUPONENVELOPE) {
          $args = $args[$t->MSG];
          $request = $args[$t->REQUEST];
          if ($args[$t->TIME] != $time) {
            return "Outbox message timestamp mismatch";
          }
        }
        $item = array();
        $item[$t->REQUEST] = $request;
        $item[$t->TIME] = $time;
        if ($request == $t->SPEND) {
          $item[$t->ID] = $args[$t->ID];
          $item[$t->NOTE] = $args[$t->NOTE];
        } elseif ($request == $t->TRANFEE) {
          // Nothing special to do here
        } elseif ($request == $t->COUPONENVELOPE) {
          $coupon = $args[$t->ENCRYPTEDCOUPON];
          if ($coupon) {
            $coupon = $this->ssl->privkey_decrypt($coupon, $this->privkey);
            $item[$t->COUPON] = $coupon;
          }
        } else {
          return "Bad request in outbox: $request";
        }
        $assetid = $args[$t->ASSET];
        $amount = $args[$t->AMOUNT];
        if ($assetid) {
          $asset = $this->getasset($assetid);
          $item[$t->ASSET] = $assetid;
          $item[$t->AMOUNT] = $amount;
          if (!is_string($asset)) {
            $item[$t->ASSETNAME] = $asset[$t->ASSETNAME];
            $item[$t->FORMATTEDAMOUNT] =
              $this->format_asset_value($amount, $asset, false);
          }
        }
        $items[] = $item;
      }
      $res[$time] = $items;
    }
    return $res;
  }

  // Redeem a coupon
  // If successful, add an inbox entry for the coupon spend and return false.
  // If fails, return error message.
  // Needs an option to process the coupon, intead of just adding it to
  // the inbox.
  function redeem($coupon) {
    $t = $this->t;
    $bankid = $this->bankid;
    $ssl = $this->ssl;

    $pubkey = $this->pubkeydb->get($bankid);
    if (!$pubkey) return "Can't get bank public key";
    
    $coupon = $ssl->pubkey_encrypt($coupon, $pubkey);
    $msg = $this->sendmsg($t->COUPONENVELOPE, $bankid, $coupon);
    $args = $this->unpack_bankmsg($msg);
    if (is_string($args)) return "redeem: $args";
    $request = $args[$t->REQUEST];
    if ($request == $t->FAILED) return "redeem: " . $args[$t->ERRMSG];
    elseif ($request != $t->ATCOUPONENVELOPE) {
      return "redeem: unexpected return type from server: $request";
    }
    return false;
  }

  // End of API methods

  // For utility->bankgetter
  function bankid() {
    return $this->bankid;
  }

  function passphrasehash($passphrase) {
    return sha1(trim($passphrase));
  }

  // Create a signed customer message.
  // Takes an arbitrary number of args.
  function custmsg() {
    $id = $this->id;
    $u = $this->u;
    $ssl = $this->ssl;
    $privkey = $this->privkey;

    $args = func_get_args();
    $args = array_merge(array($id), $args);
    $msg = $u->makemsg($args);
    $sig = $ssl->sign($msg, $privkey);
    return trim("$msg:\n$sig");
  }

  // Send a customer message to the server.
  // Takes an arbitrary number of args.
  function sendmsg() {
    $server = $this->server;

    $req = func_get_args();
    $msg = call_user_func_array(array($this, 'custmsg'), $req);
    return $server->process($msg);
  }

  // Unpack a bank message
  // Return a string if parse error or fail from bank
  // This is called via the $unpacker arg to utility->dirhash & balancehash
  function unpack_bankmsg($msg, $request=false, $bankid=false) {
    $parser = $this->parser;

    $reqs = $parser->parse($msg);
    if (!$reqs) return "Parse error: " . $parser->errmsg;

    $req = $reqs[0];
    $args = $this->match_bankreq($req, $request, $bankid);
    if (!is_string($args)) {
      $args[$this->unpack_reqs_key] = $reqs; // save parse results
    }
    return $args;
  }

  // Unpack a bank message that has already been parsed
  function match_bankreq($req, $request=false, $bankid=false) {
    $t = $this->t;
    $u = $this->u;
    if (!$bankid) $bankid = $this->bankid;

    $args = $u->match_pattern($req);
    if (is_string($args)) return "While matching: $args";
    if ($args[$t->CUSTOMER] != $bankid) return "Return message not from bank";
    if ($args[$t->REQUEST] == $t->FAILED) return $args[$t->ERRMSG];
    if ($request && $args[$t->REQUEST] != $request) {
      return "Wrong return type from bank; sb: $request, was: " . $args[$t->REQUEST];
    }
    if ($args[$t->MSG]) {
      $msgargs = $u->match_pattern($args[$t->MSG]);
      if (is_string($msgargs)) return "While matching bank-wrapped msg: $msgargs";
      if (array_key_exists($t->BANKID, $msgargs) &&
          $msgargs[$t->BANKID] != $bankid) {
        return "While matching bank-wrapped msg: bankid mismatch";
      }
      $args[$t->MSG] = $msgargs;
    }
    return $args;
  }

  function pubkey($id) {
    $db = $this->pubkeydb;
    return $db->get($id);
  }

  function pubkeykey($id) {
    $t = $this->t;
    return $t->PUBKEY . "/$id";
  }

  function bankkey($prop=false, $bankid=false) {
    $t = $this->t;
    if (!$bankid) $bankid = $this->bankid;

    $key = $t->BANK . "/$bankid";
    return $prop ? "$key/$prop" : $key;
  }

  function bankprop($prop, $bankid=false) {
    $db = $this->db;

    return $db->get($this->bankkey($prop, $bankid));
  }

  function assetkey($assetid=false) {
    $t = $this->t;

    $key = $this->bankkey($t->ASSET);
    if ($assetid) $key .= "/$assetid";
    return $key;
  }

  function assetprop($assetid) {
    $db = $this->db;

    return $db->get($this->assetkey($assetid));
  }

  function tranfeekey() {
    $t = $this->t;

    return $this->bankkey($t->TRANFEE);
  }

  function tranfee() {
    $db = $this->db;

    return $db->get($this->tranfeekey());
  }

  function regfeekey() {
    $t = $this->t;

    return $this->bankkey($t->REGFEE);
  }

  function regfee() {
    $db = $this->db;

    return $db->get($this->regfeekey());
  }

  function userbankkey($prop=false, $bankid=false) {
    $t = $this->t;
    $id = $this->id;
    if (!$bankid) $bankid = $this->bankid;

    $key = $t->ACCOUNT . "/$id/" . $t->BANK . "/$bankid";
    return $prop ? "$key/$prop" : $key;
  }

  function userbankprop($prop, $bankid=false) {
    $db = $this->db;

    return $db->get($this->userbankkey($prop, $bankid));
  }

  function userreqkey($bankid=false) {
    $t = $this->t;

    return $this->userbankkey($t->REQ, $bankid);
  }

  function userreq($bankid=false) {
    $db = $this->db;

    return $db->get($this->userreqkey($bankid));
  }

  function usertimekey() {
    $t = $this->t;

    return $this->userbankkey($t->TIME);
  }

  // Called via $unpacker->balancekey() in utility->balancehash()
  function balancekey($id) {
    if ($id != $this->id) die("ID mismatch in client->balancekey()");
    return $this->userbalancekey();
  }

  function userbalancekey($acct=false, $assetid=false) {
    $t = $this->t;

    $key = $this->userbankkey($t->BALANCE);
    if ($acct) {
      $key .= "/$acct";
      if ($assetid) $key .= "/$assetid";
    }
    return $key;
  }

  function userbalance($acct, $assetid) {
    $db = $this->db;
    $t = $this->t;

    $msg = $db->get($this->userbalancekey($acct, $assetid));
    if ($msg) {
      $args = $this->unpack_bankmsg($msg, $t->ATBALANCE);
      if (is_string($args)) return $args;
      $args = $args[$t->MSG];
      return $args[$t->AMOUNT];
    }
    return false;
  }

  function useroutboxkey($time=false) {
    $t = $this->t;

    $key = $this->userbankkey($t->OUTBOX);
    if ($time) $key .= "/$time";
    return $key;
  }

  function useroutbox($time) {
    $db = $this->db;

    return $db->get($this->useroutboxkey($time));
  }

  function useroutboxhashkey() {
    $t = $this->t;

    return $this->userbankkey($t->OUTBOXHASH);
  }

  function useroutboxhash() {
    $db = $this->db;

    return $db->get($this->useroutboxhashkey());
  }

  function userbalancehashkey() {
    $t = $this->t;

    return $this->userbankkey($t->BALANCEHASH);
  }

  function userbalancehash() {
    $db = $this->db;

    return $db->get($this->userbalancehashkey());
  }

  function userinboxkey() {
    $db = $this->db;
    $t = $this->t;

    return $this->userbankkey($t->INBOX);
  }

  function contactkey($otherid=false, $prop=false) {
    $t = $this->t;

    $res = $this->userbankkey($t->CONTACT);
    if ($otherid) {
      $res .= "/$otherid";
      if ($prop) $res .= "/$prop";
    }
    return $res;
  }

  function contactprop($otherid, $prop) {
    $db = $this->db;

    $key = $this->contactkey($otherid, $prop);
    return $db->get($this->contactkey($otherid, $prop));
  }

  // format an asset value from the asset ID or $this->getasset($assetid)
  function format_asset_value($value, $assetid, $incnegs=true) {
    $t = $this->t;

    if (is_string($assetid)) $asset = $this->getasset($assetid);
    else $asset = $assetid;
    if (is_string($asset)) return $value;
    return $this->format_value($value, $asset[$t->SCALE], $asset[$t->PRECISION], $incnegs);
  }

  // Unformat an asset value from the asset ID or $this->getasset($assetid)
  function unformat_asset_value($formattedvalue, $assetid) {
    $t = $this->t;

    if (is_string($assetid)) $asset = $this->getasset($assetid);
    else $asset = $assetid;
    if (is_string($asset)) return $value;
    return $this->unformat_value($formattedvalue, $asset[$t->SCALE]);
  }

  // format an asset value for user printing
  function format_value($value, $scale, $precision, $incnegs=true) {
    $sign = 1;
    if ($incnegs && bccomp($value, 0) < 0) {
      $value = bcadd($value, 1);
      $sign = -1;
    }
    if ($scale == 0 && $precision == 0) $res = $value;
    else {
      if ($scale > 0) {
        $res = bcdiv($value, bcpow(10, $scale), $scale);
      }
      $dotpos = strpos($res, '.');
      if ($dotpos === false) {
        if ($precision != 0) {
          $res .= '.' . str_repeat('0', $precision);
        }
      } else {
        // Remove trailing zeroes
        for ($endpos = strlen($res)-1; $endpos>$dotpos; $endpos--) {
          if ($res[$endpos] != '0') break;
        }
        $zeroes = $precision - ($endpos - $dotpos);
        $zerostr = ($zeroes >= 0) ? str_repeat('0', $zeroes) : '';
        $res = substr($res, 0, $endpos+1) . $zerostr;
      }
    }
    if ($value == 0 && $sign < 0) $res = "-$res";
    return $res;
  }

  function unformat_value($formattedvalue, $scale) {
    if ($scale == 0) $value = $formattedvalue;
    else $value = bcmul($formattedvalue, bcpow(10, $scale), 0);
    if ((bccomp($value, 0) < 0) ||
        ($value == 0 && substr($formattedvalue, 0, 1) == '-')) {
      $value = bcsub($value, 1);
    }
    return $value;
  }

  // Send a t->ID command to the server, if there is one.
  // Parse out the pubkey, cache it in the database, and return it.
  // Return the empty string if there is no server or it doesn't know
  // the id.
  // If $wholemsg is true, return the $args for the whole $t->REGISTER
  // message, intead of just the pubkey, and return an error message,
  // instead of the empty string, if there's a problem.
  function get_pubkey_from_server($id, $wholemsg=false) {
    $t = $this->t;
    $db = $this->db;
    $bankid = $this->bankid;

    if (!$this->current_bank()) {
      return $wholemsg ? 'In get_pubkey_from_server: Bank not set' : '';
    }

    $msg = $this->sendmsg($t->ID, $bankid, $id);
    $args = $this->unpack_bankmsg($msg, $t->ATREGISTER);
    if (is_string($args)) return $wholemsg ? $args : '';
    $args = $args[$t->MSG];
    $pubkey = $args[$t->PUBKEY];
    $pubkeykey = $this->pubkeykey($id);
    if ($pubkey) {
      if (!$db->get($pubkeykey)) $db->put($pubkeykey, $pubkey);
      if ($wholemsg) return $args;
      return $pubkey;
    }
    return $wholemsg ? "Can't find pubkey on server" : '';
  }

  // Get a new request
  function getreq() {
    $t = $this->t;
    $db = $this->db;

    $key = $this->userreqkey();
    $lock = $db->lock($key);
    $reqnum = $this->getreq_internal($key);
    $db->unlock($lock);

    return $reqnum;
  }

  function getreq_internal($key) {
    $t = $this->t;
    $db = $this->db;

    $reqnum = bcadd($db->get($key), 1);
    $db->put($key, $reqnum);
    return $reqnum;
  }

  // Get a timestamp from the server
  function gettime($forcenew=false) {
    $t = $this->t;
    $db = $this->db;
    $bankid = $this->bankid;

    $key = $this->usertimekey();
    if ($forcenew) $db->put($key, '');
    else {
      $times = $db->get($key);
      if ($times) {
        $times = explode(',', $times);
        $time = $times[0];
        $db->put($key, $times[1]);
        return $time;
      }
    }

    $req = $this->getreq();
    if (!$req) return false;
    $msg = $this->sendmsg($t->GETTIME, $bankid, $req);
    $args = $this->unpack_bankmsg($msg, $t->TIME);
    if (is_string($args)) return false;
    return $args[$t->TIME];
  }

  // Check once per instance that the local idea of the reqnum matches
  // that at the bank.
  // If it doesn't, clear the account information, so that initbankaccts()
  // will reinitialize.
  // Eventually, we want to compare to see if we can catch a bank error.
  function syncreq() {
    $db = $this->db;
    $t = $this->t;

    $key = $this->userbankkey($t->REQ);
    $reqnum = $db->get($key);
    if ($reqnum == -1) $this->syncedreq = true;
    if (!$this->syncedreq) {
      $bankid = $this->bankid;
      $msg = $this->sendmsg($t->GETREQ, $bankid);
      $args = $this->unpack_bankmsg($msg, $t->REQ);
      if (is_string($args)) return false;
      $newreqnum = $args[$t->REQ];
      if ($reqnum != $newreqnum) {
        $reqnum = -1;
        $balkey = $this->userbalancekey();
        $accts = $db->contents($balkey);
        foreach ($accts as $acct) {
          $acctkey = "$balkey/$acct";
          $assetids = $db->contents($acctkey);
          foreach ($assetids as $assetid) {
            $key = "$acctkey/$assetid";
            $db->put($key, '');
          }
        }
        $outboxkey = $this->useroutboxkey();
        $outtimes = $db->contents($outboxkey);
        foreach ($outtimes as $outtime) {
          $key = "$outboxkey/$outtime";
          $db->put($key, '');
        }
        $db->put($this->userbalancehashkey(), '');
        $db->put($this->useroutboxhashkey(), '');
      }
      $this->syncedreq = true;
    }
    return $reqnum;
  }

  // Force a reinit of the client database for the current user
  function forceinit() {
    $db = $this->db;

    $db->put($this->userreqkey(), 0);
    $this->syncedreq = false;
    return $this->initbankaccts();
  }

  // If we haven't yet downloaded accounts from the bank, do so now.
  // This is how a new client instance gets initialized from an existing
  // bank instance.
  // Return false on success or error string.
  function initbankaccts() {
    $t = $this->t;
    $db = $this->db;
    $id = $this->id;
    $bankid = $this->bankid;
    $parser = $this->parser;

    $reqnum = $this->syncreq();

    if ($reqnum == -1) {

      // Get $t->REQ
      $msg = $this->sendmsg($t->GETREQ, $bankid);
      $args = $this->unpack_bankmsg($msg, $t->REQ);
      if (is_string($args)) return "While getting req to initialize accounts: $args";
      $reqnum = bcadd($args[$t->REQ], 1);

      // Get account balances
      $msg = $this->sendmsg($t->GETBALANCE, $bankid, $reqnum);
      $reqs = $parser->parse($msg);
      if (!$reqs) {
        if ($parser->errmsg) {
          return "While parsing getbalance: " . $parser->errmsg;
        }
        $reqs = array();
      }
      $balances = array();
      $balancehash = false;
      foreach ($reqs as $req) {
        $args = $this->match_bankreq($req);
        if (is_string($args)) return "While matching getbalance: $args";
        $request = $args[$t->REQUEST];
        $msgargs = $args[$t->MSG];
        $customer = $msgargs[$t->CUSTOMER];
        if ($msgargs && $customer != $id) {
          return "Bank wrapped somebody else's ($customer) message: $msg";
        }
        if ($request == $t->ATBALANCE) {
          if ($msgargs[$t->REQUEST] != $t->BALANCE) {
            return "Bank wrapped a non-balance request with @balance";
          }
          $assetid = $msgargs[$t->ASSET];
          if (!$assetid) return "Bank wrapped balance missing asset ID";
          $acct = $msgargs[$t->ACCT];
          if (!$acct) $acct = $t->MAIN;
          $balances[$acct][$assetid] = $parser->get_parsemsg($req);
        } else if ($request == $t->ATBALANCEHASH) {
          $balancehash = $parser->get_parsemsg($req);
        }
      }

      // Get outbox
      $reqnum = bcadd($reqnum, 1);
      $msg = $this->sendmsg($t->GETOUTBOX, $bankid, $reqnum);
      $reqs = $parser->parse($msg);
      if (!$reqs) return "While parsing getoutbox: " . $parser->errmsg;
      $outbox = array();
      $outboxhash = '';
      $outboxtime = false;
      foreach ($reqs as $req) {
        $args = $this->match_bankreq($req);
        if (is_string($args)) return "While matching getoutbox: $args";
        $request = $args[$t->REQUEST];
        $msgargs = $args[$t->MSG];
        $customer = $msgargs[$t->CUSTOMER];
        if ($msgargs && $msgargs[$t->CUSTOMER] != $id) {
          return "Bank wrapped somebody else's ($customer) message: $msg";
        }
        if ($request == $t->ATGETOUTBOX) {
          $outboxtime = false;
        } elseif ($request == $t->ATSPEND) {
          if ($msgargs[$t->REQUEST] != $t->SPEND) {
            return "Bank wrapped a non-spend request with @spend";
          }
          $time = $msgargs[$t->TIME];
          $outbox_time = $time;
          $outbox[$time] = $parser->get_parsemsg($req);
        } elseif ($request == $t->ATTRANFEE) {
          if ($msgargs[$t->REQUEST] != $t->TRANFEE) {
            return "Bank wrapped a non-tranfee request with @tranfee";
          }
          $time = $msgargs[$t->TIME];
          $msg = $outbox[$time];
          if (!$msg) return "No spend message for time: $time";
          $msg = "$msg." . $parser->get_parsemsg($req);
          $outbox[$time] = $msg;
        } elseif ($request == $t->ATOUTBOXHASH) {
          if ($msgargs[$t->REQUEST] != $t->OUTBOXHASH) {
            return "Bank wrapped a non-outbox request with @outboxhash";
          }
          $outboxhash = $parser->get_parsemsg($req);
        } elseif ($request == $t->COUPONENVELOPE) {
          if (!$outbox_time) return "Got a coupon envelope with no outboxtime";
          $msg = $outbox[$outbox_time];
          if (!$msg) return "No spend message for coupon envelope";
          $msg = "$msg." . $parser->get_parsemsg($req);
          $outbox[$outbox_time] = $msg;
          $outbox_time = false;
        } else {
          return "While processing getoutbox: bad request: $request";
        }
      }

      if (count($outbox) > 0 && !$outboxhash) {
        return "While procesing getouxbox: outbox items but no outboxhash";
      }

      // All is well. Write the data
      foreach ($balances as $acct => $assets) {
        foreach ($assets as $assetid => $msg) {
          $db->put($this->userbalancekey($acct, $assetid), $msg);
        }
      }

      if ($balancehash) {
        $db->put($this->userbalancehashkey(), $balancehash);
      }

      foreach ($outbox as $time => $msg) {
        $db->put($this->useroutboxkey($time), $msg);
      }
      $db->put($this->useroutboxhashkey(), $outboxhash);
      $db->put($this->userreqkey(), $reqnum);
    }
    return false;
  }

  function balancehashmsg($time, $acctbals) {
    $u = $this->u;
    $t = $this->t;
    $db = $this->db;
    $bankid = $this->bankid;

    $hasharray = $u->balancehash($db, $this->id, $this, $acctbals);
    $hash = $hasharray[$t->HASH];
    $hashcnt = $hasharray[$t->COUNT];
    $balancehash = $this->custmsg($t->BALANCEHASH, $bankid, $time, $hashcnt, $hash);

    return $balancehash;
  }


  function outboxhashmsg($transtime, $newitem=false, $removed_times=false) {
    $db = $this->db;
    $u = $this->u;
    $t = $this->t;

    $hasharray = $u->dirhash
      ($db, $this->useroutboxkey(), $this, $newitem, $removed_times);
    $hash = $hasharray[$t->HASH];
    $hashcnt = $hasharray[$t->COUNT];
    return $this->custmsg($this->t->OUTBOXHASH,
                          $this->bankid,
                          $transtime,
                          $hashcnt,
                          $hash);
  }

  // Web client session support

  // Return a new, random, session ID
  function newsessionid() {
    $random = $this->random;
    if (!$random) {
      require_once "LoomRandom.php";
      $random = new LoomRandom();
      $this->random = $random;
    }
    $res = bin2hex($random->urandom_bytes(20));
    if (strlen($res) < 40) $res = str_repeat("0", 40 - strlen($res)) . $res;
    return $res;
  }

  // xor hashed copies of $key with $string and return the result.
  // This is a really simple encryption that only really works if
  // $key is known to be random, e.g. the output of newsessionid().
  function xorcrypt($key, $string) {
    $key = @pack("H*", sha1($key));
    $idx = 0;
    $keylen = strlen($key);
    $len = strlen($string);
    $res = '';
    for ($i=0; $i<$len; $i++) {
      $res .= chr(ord(substr($key, $idx, $idx+1)) ^ ord(substr($string, $i, $i+1)));
      $idx++;
      if ($idx >= $keylen) {
        $idx = 0;
        $key = @pack("H*", sha1($key));
        $keylen = strlen($key);
      }
    }
    return $res;
  }

  // Return the database key for the user's session hash.
  function usersessionkey() {
    $t = $this->t;
    $id = $this->id;

    return $t->ACCOUNT . "/$id/" . $t->SESSION;
  }

  // Return the user's session hash.
  function usersessionhash() {
    $db = $this->db;

    return $db->get($this->usersessionkey());
  }

  // Return the database key for a session hash
  function sessionkey($sessionhash) {
    $t = $this->t;

    return $t->SESSION . "/$sessionhash";
  }

  // Return the passphrase corresponding to a session id
  function sessionpassphrase($sessionid) {
    $db = $this->db;

    $passcrypt = $db->get($this->sessionkey(sha1($sessionid)));
    return $this->xorcrypt($sessionid, $passcrypt);
  }

  // Create a new user session, encoding $passphrase with a new session id.
  // Return the new session id.
  // If the user already has a session stored with another session id,
  // remove that one first.
  function makesession($passphrase) {
    $db = $this->db;

    $sessionid = $this->newsessionid();
    $passcrypt = $this->xorcrypt($sessionid, $passphrase);
    $usersessionkey = $this->usersessionkey();
    $lock = $db->lock($usersessionkey);
    $oldhash = $db->get($usersessionkey);
    if ($oldhash) {
      $db->put($this->sessionkey($oldhash), '');
    }
    $newhash = sha1($sessionid);
    $db->put($this->sessionkey($newhash), $passcrypt);
    $db->put($usersessionkey, $newhash);
    $db->unlock($lock);
    return $sessionid;
  }

  // Remove the current user's session
  function removesession() {
    $db = $this->db;

    $usersessionkey = $this->usersessionkey();
    $lock = $db->lock($usersessionkey);
    $oldhash = $db->get($usersessionkey);
    if ($oldhash) {
      $db->put($this->sessionkey($oldhash), '');
      $db->put($usersessionkey, '');
    }
    $db->unlock($lock);
  }

  // Preferences
  function userpreferencekey($pref) {
    $t = $this->t;
    $id = $this->id;

    return $t->ACCOUNT . "/$id/" . $t->PREFERENCE . "/$pref";
  }

  // Get or set a user preference.
  // Include the $value to set.
  function userpreference($pref, $value=true) {
    $db = $this->db;

    $key = $this->userpreferencekey($pref);
    if ($value === true) $value = $db->get($key);
    else $db->put($key, $value);
    return $value;
  }

  // Account creation tokens
  // A kluge to keep spammers out of my web client

  function tokenkey($token=false) {
    $t = $this->t;
    
    $key = $t->TOKEN;
    if ($token) $key .= "/$token";
    return $key;
  }

  function token($token, $value=false) {
    $db = $this->db;

    $key = $this->tokenkey($token);
    if ($value === false) return $db->get($key);
    else {
      $db->put($key, $value);
      return $value;
    }
  }

  // Returns array($tok => $value, ...)
  function gettokens() {
    $db = $this->db;

    $tokens = $db->contents($this->tokenkey());
    $res = array();
    foreach ($tokens as $tok) {
      $res[$tok] = $db->get($this->tokenkey($tok));
    }
    return $res;
  }

  // Predicate. True if arg looks like an ID
  function is_id($x) {
    return is_string($x) && strlen($x) == 40 && @pack("H*", $x);
  }

  // Predicate. True if arg looks like an coupon
  function is_coupon_number($x) {
    return is_string($x) && strlen($x) == 32 && @pack("H*", $x);
  }

  // Add a string to the debug output.
  // Does NOT add a newline.
  // Use var_export($val, true) to dump arrays
  function debugmsg($x) {
    $showfun = $this->showprocess;
    if ($showfun) @$showfun($x);
  }

}

class serverproxy {
  var $url;
  var $client;

  function serverproxy($url, $client=false) {
    $this->url = $url;
    $this->client = $client;
  }

  // From http://us.php.net/manual/en/function.stream-context-create.php#72017
  function post($url, $post_variables=array()) {
    $content = http_build_query($post_variables);
    $content_length = strlen($content);
    $options = array
      ('http'=>array('method' => 'POST',
                     'header' =>
                     "User-Agent: Trubanc\r\n" .
                     "Content-type: application/x-www-form-urlencoded\r\n" . 
                     "Content-length: $content_length\r\n",
                     'content' => $content));
    $context = stream_context_create($options);
    return @file_get_contents($url, false, $context);
  }

  function process($msg) {
    $url = $this->url;
    $client = $this->client;
    $db = $client->db;

    // This is a kluge to get around versions of Apache that insist
    // on sending "301 Moved Permanently" for directory URLs that
    // are missing a trailing slash.
    // file_get_contents doesn't resend the post data in that case
    // This will break URLs that are to files intead of directories.
    // As part of adding a bank, I should really do the raw send without
    // params and see if I get a 301.
    if (substr($url,-1) != '/') $url = $url .= '/';

    $vars = array('msg' => $msg);

    $debugfile = '';
    if ($client->showprocess) {
      $debugdir = realpath($db->dir);
      $debugfile = 'serverdebug/' . $client->newsessionid();
      $vars['debugdir'] = $debugdir;
      $vars['debugfile'] = $debugfile;
    }

    $client->debugmsg("===SENT: $msg\n");

    $res = $this->post($url, $vars);

    if ($debugfile) {
      $text = $db->get($debugfile);
      if ($text) {
        $db->put($debugfile, '');
        $client->debugmsg("===SERVER SAID: $text");
      }
    }
    $client->debugmsg("===RETURNED: $res\n");

    return $res;
  }
}

// Look up a public key, from the client database first, then from the
// current bank.
class pubkeydb {

  var $client;
  var $pubkeydb;

  var $insidep = false;

  function pubkeydb($client, $pubkeydb) {
    $this->client = $client;
    $this->pubkeydb = $pubkeydb;
  }

  function get($id) {
    $pubkeydb = $this->pubkeydb;
    $client = $this->client;

    $res = $pubkeydb->get($id);
    if ($res) return $res;

    if ($this->insidep) return "";
    $this->insidep = true;
    $res = $client->get_pubkey_from_server($id);
    $this->insidep = false;
    return $res;
  }
}

// Copyright 2008 Bill St. Clair
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions
// and limitations under the License.

?>
